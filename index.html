<html>
<head>
  <title>Font Force Field Tool</title>
  <style>
body {
  font-family: "Calibri";
  background-color: #f0f0e0;
}
#inputText {
  font-size: 150%;
}
#svgResult {
  touch-action: none;
}
.tableColumnHead {
  background-color: #ddb;
}
table, th, td {
  border-collapse: collapse;
  padding: 2px;
}
.dropbtn {
  border-radius: 4px;
  background-color: rgba(96,192,128,0.5);
  color: black;
  padding: 6px;
  border: none;
  cursor: pointer;
  font-weight: bold;
  font-size: 100%
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  align: left;
  border-radius: 2px 8px 12px 12px;
  display: none;
  position: absolute;
  background-color: #eff;
  min-width: 200px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}
.dropdown-content a{
  color: black;
  padding: 8px 12px;
  text-decoration: none;
  display: block;
}
th .dropdown-content{
  text-align: left;
  font-weight: bold;
  font-size: 100%;
}
table .dropdown-content {
  padding: 10px;
}
.dropdown-content a:hover {background-color: #cee;}
.dropdown:hover .dropdown-content {
  display: block;
}
.dropdown:hover .dropbtn {
  background-color: #3e8e41;
  color: white;
}
.tooltip {
  position: relative;
  display: inline-block;
  border-bottom: 1px dotted #ccc;
  color: #006080;
}
.tooltip .tooltiptext {
  visibility: hidden;
  position: absolute;
  width: 340px;
  background-color: #555;
  color: #fff;
  text-align: center;
  padding: 5px 0;
  border-radius: 6px;
  z-index: 1;
  opacity: 0;
  transition: opacity 0.3s;
}
.tooltip:hover .tooltiptext {
  visibility: visible;
  opacity: 1;
}
.tooltip-bottom {
  top: 135%;
  left: 50%;
  margin-left: -60px;
}
.tooltip-bottom::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  margin-width: 5px;
  border-style: solid;
  border-color: transparent transparent #555 transparent;
}

dialog::backdrop {
  background-color: hsl(60, 40%, 50%, 0.5);
}
dialog {
  background-color: #e8ece8;
}
[aria-label="close"] {
  appearance: none;
  background-color: #fcc;
  float: right;
  border: 1px solid;
  border-radius: 50%;
}
#debugInput {
  font-family: "Lucida Console", monospace;
  font-size: 100%;
}
#debugOutput {
  font-family: "Lucida Console", monospace;
  font-size: 100%;
  background-color: #eee;
}
</style>
<script type="text/javascript" src="js/hb.js"></script> <!-- Module - REQUIRED -->
<script type="text/javascript" src="js/hbjs.js"></script>
<script type="text/javascript" src="js/flatbezier.js"></script>
<script type="module" src="./js/opentype.min.mjs" async></script>
<script type="text/javascript" src="./js/otinfo.min.js"></script>
</head>

<body>
<h1>Font Force Field Tool</h1>

<table id='tableOptions' width='100%' border=1>
<tr><td width='60%' valign='top'>
  <table border=0 width='100%'>
    <tr><td width='25%'>Font:</td><td id='theFont'><div id='fontInfo'>-font-</div></td></tr>
  </table>
</td><td>
</td>
</tr>
<tr><th class='tableColumnHead'>Adhoc Test</th><th class='tableColumnHead'>List Processing</th></tr>
<tr><td valign="top">
  <table border=0 width='100%'>
  <tr><td width='25%'>Text:</td><td><input type="text" style="width:60%" id="inputText" oninput="updateValues();" value="abc"></input>
    <div class='dropdown'>
      <button class='dropbtn'>&#x1F30D;HarfBuzz</button>
      <div class='dropdown-content'>
        <table border=0 width='100%'>
          <tr><th>Script:</th><td>
            <span class='tooltip'>
              <input type='text' id='inputScript' oninput='updateScriptLanguage();'/>
              <span class='tooltiptext tooltip-bottom' id='inputScriptList'>-</span>
            </span>
          </td></tr>
          <tr><th>Language:</th><td>
            <span class='tooltip'>
              <input type='text' id='inputLanguage' oninput='updateScriptLanguage();'/>
              <span class='tooltiptext tooltip-bottom' id='inputLanguageList'>-</span>
            </span>
          </td></tr>
        </table>  
      </div>
    </div>
  </td></tr>
  <tr><td>Ranges:</td><td id='rangeChoice'>
    <input type='radio' id='showSliders' name='rangeSettings' value='sliders' checked>Sliders</input>
    <input type='radio' id='showJSON'    name='rangeSettings' value='JSON'>JSON</input>
  </td></tr>
</table>
<span id='slidersDiv'>
<table width='100%' id='slidersTable'>
  <tr><td width='25%'>Base Near:</td><td><input type="range" style="width:60%" value="45"  min="0" max="100" step="1" id="baseNear" oninput="updateValues();"><label id='baseNearValue'></label></td></tr>
  <tr><td>Base Far:</td><td><input type="range" style="width:60%"  value="95" min="0" max="500" step="1" id="baseFar" oninput="updateValues();"><label id='baseFarValue'></label></td></tr>
  <tr><td>Mark Near:</td><td><input type="range" style="width:60%"  value="10"  min="0" max="100" step="1" id="markNear" oninput="updateValues();"><label id='markNearValue'></label></td></tr>
  <tr><td>Mark-Base Near:</td><td><input type="range" style="width:60%"  value="5"  min="0" max="100" step="1" id="markNearBase" oninput="updateValues();"><label id='markNearBaseValue'></label></td></tr>
  <tr><td>Mark Far:</td><td><input type="range" style="width:60%"  value="100" min="0" max="500" step="1" id="markFar" oninput="updateValues();"><label id='markFarValue'></label></td></tr>
</table>
</span>
<span id='jsonDiv' hidden>
<table width='100%' id='jsonTable'>
  <tr><td width='25%'>JSON:</td>
    <td>
      <textarea style="width:90%" id="jsonText" cols='40' rows='8' wrap='off' oninput="updateJSON();" spellcheck="false">
//** Drag and Drop .json or .txt **//

// e.g.
{
  font:{
    name:'MyFontName',
    version:'Exact Version'
  },  // Warning if different

  // 'n'  = Near
  // 'f'  = Far
  // 'nb' = Near Base (mark to glyph or cursive group)

  base:{n:45, f:95},

  mark:{n:10, nb:5, f:100},

  // GID specific
  //'643':{n:'120%',f:'200%'},  // Using percentages
  //'644':{n:15,    f:50},      // Explicit values

  //'454':{n:'80%', nb:'50%', f:40},  // Mixed. `nb` = mark-to-base near field
}
      </textarea>
      </br>
      <div id='jsonError' style='color:red'>-</div>
    </td></tr>
</table>
</span>
<table width='100%'>
  <tr><td width='25%'>Colours:</td><td>
    <input type="checkbox" id="cbShowGlyphs" checked><label for="cbShowGlyphs">Glyphs</label>
    <input type='radio' id='colourGlyph' name='renderColour' value='glyph' checked>Glyph</input>
    <input type='radio' id='colourSolid' name='renderColour' value='solid'>Solid</input>
  </td></tr>
  <tr><td>Fields:</td><td>
    <input type="checkbox" id="cbShowNear" checked><label for="cbShowNear">Near</label>
    <input type="checkbox" id="cbShowNearBase" checked><label for="cbShowNearBase">Near Base</label>
    <input type="checkbox" id="cbShowFar" checked><label for="cbShowFar">Far</label>
    <input type="checkbox" id="cbShowFarMarks" checked><label for="cbShowFarMarks">Far Marks</label>
    <input type="checkbox" id="cbShowFarExtra"><label for="cbShowFarExtra">Far Extra</label>    
    <input type="checkbox" id="cbShowCollisions" checked><label for="cbShowCollisions">Collisions</label>
  </td></tr>
  <tr><td>Options:</td><td>
    <input type="checkbox" id="cbShowGids" checked><label for="cbShowGids">GIDs</label>
    <input type="checkbox" id="cbShowGidNames" disabled><label for="cbShowGidNames">Names</label>
    <!--<button onclick="copyGlyphNames();" id="btnCopyGlyphNames" disabled>Copy Glyph Names</button>-->
    <button onclick="dialogDebug.showModal();" id="btnDebug">Debug</button>
    <dialog id="dialogDebug">
      <button type="submit" aria-label="close" onclick="dialogDebug.close();">X</button>
      <h2>Debug</h2>
      <!--<form>-->
        <input type="text" id="debugInput"/><br/>JSON:<span id="debugJson"></span><br/>
        <button onclick="debugGlyphNames();" id="btnDebugNames" title="Show all glyph names">Names</button> 
        <button onclick="debugGroups();" id="btnDebugGroups" title="Show all JSON groups">Groups</button> 
        <button onclick="debugGroup();" id="btnDebugGroup" title="Show group info for the input text">Group</button> 
        <button onclick="debugGIDs();" id="btnDebugGIDs" title="Show the glyph IDs for the input text (group, wildcard, regexp)">GIDs</button> 
        <button onclick="debugOverlaps();" id="btnDebugOverlaps" title="Show all overlap sets for the GID in the input field">Overlaps</button>
        <button onclick="debugBar();" id="btnDebugBar" title="Show all the GIDs in the bar set">Bar</button><br/>
        <textarea id="debugOutput" style="width:100%;" cols='60' rows='32' wrap='off' style='font-family:monospace;' spellcheck="false"></textarea>
        <br/><button onclick="debugCopy();">Copy to Clipboard</button>
      <!--</form>-->
    </dialog>
  </td></tr>
  <tr><td>Collisions:</td><td><span style='color:red' id='colNotify'></span></td></tr>
  <tr><td>Too Far:</td><td><span style='color:red' id='farNotify'></span></td></tr>
  <tr><td>Output:</td><td><span style='color:blue' id='wordRating'></span></td></tr>
  </table>
</td>
<td width='50%' valign='top'>
  <table border=0 width='100%' id='WordsDragDrop'>
  <tr><td width='25%'>Word List:</td>
    <td>
      <div id='wordListDetails'>(drag .txt. file here)</div>
      <button hidden onclick='rateWordList();' id='btnRateWordList'>Rate!</button>
      <button onclick='saveResults();' hidden id='saveListButton'>Save List</button>
      <div id='divFarExtraMark' hidden>
        <br/><input type='checkbox' id='cbFarExtraMark' title='Include mark path in the extra far base (takes longer!)'>Include Mark in Extra Far</input>
      </div>
    </td>
  </tr>
  <tr><td>Progress:</td><td><div id='statusUpdate'>-</div> <button onclick='AbortProgress();' id='AbortButton' hidden>Abort!</button></td></tr>
  <tr><td>Stats:</td><td><div id='statusCounts'>-</div></td></tr>
  <tr><td>Word:</td><td>
    <button onclick='randomWord(false);'>Failed</button>
    <button onclick='randomWord(true);'>Passed</button></br>
    <button onclick='pickWord(0);'  accesskey='1'>First (Alt-1)</button>
    <button onclick='pickWord(-1);' accesskey='2'>Prev (Alt-2)</button>
    <button onclick='pickWord(1);'  accesskey='3'>Next (Alt-3)</button>
    <button onclick='pickWord(9);'  accesskey='4'>Last (Alt-4)</button>
    </br>
      <input type="text" id='wordIndex' hidden></input><button id='wordIndexGo'>Go</button>
  </td></tr>
  <tr><td>Sync:</td><td>
    <button onclick='openFontCompareWordListTool();' id='btnFCWL'>Font Compare Word List</button>
  </td></tr>
  </table>
</td>
</tr>
</table>

<span id='infoText'></span>

<!--<canvas id="myCanvas" width="1000" height="500" resize
viewBox="-250 -1800 1500 1000" preserveAspectRatio="none"
></canvas>-->

<div id="svgResult"></div>
<p>
  <button id="saveSvg" onclick="DownloadSvg();">Download SVG</button>
  <button id="zoomOutSVG" onclick="zoomSVG(-1);">-</button>
  <button id="zoomResetSVG" onclick="zoomSVG(0);" title="Middle click or Shift-Left and drag to pan the SVG">100%</button>
  <button id="zoomInSVG" onclick="zoomSVG(1);">+</button>
  <font size=-1>&nbsp; Shift-Scroll to zoom. Left-Mouse to drag.</span>

<script>
"use strict";

// polyfill for scheduler.yield
globalThis.scheduler = globalThis.scheduler || {};
globalThis.scheduler.yield = 
  globalThis.scheduler.yield || 
  (() => new Promise((r) => setTimeout(r, 0)));


function DownloadSvg() {
  var tempLink = document.createElement("a");
  var taBlob = new Blob([svgResult.innerHTML.replace(' height="512"', '')], { type: 'text/plain' });
  tempLink.setAttribute('href', URL.createObjectURL(taBlob));
  tempLink.setAttribute('download', 'fontforcefield.'+inputText.value + '.svg');
  tempLink.click();
  URL.revokeObjectURL(tempLink.href);
}

function updateSvg(dive, html) {
  var oldScale = 1;
  var oldTranslate = {x:0, y:0};

  var svge = dive.children[0];
  if (typeof svge !== 'undefined') {
    oldScale = svge.currentScale;
    oldTranslate = svge.currentTranslate;
  }
  dive.innerHTML = html;
  svge = dive.children[0];
  svge.currentScale = oldScale;
  svge.currentTranslate.x = oldTranslate.x;
  svge.currentTranslate.y = oldTranslate.y;
}

function adjustSVGzoom(svge, amount) {
  var newScale
  if (amount < 0){newScale=svge.currentScale/1.1}
  if (amount > 0){newScale=svge.currentScale*1.1}
  if (amount ==0){newScale=1}
  var oldScale=svge.currentScale
  var y = svge.clientHeight / 2;
  svge.currentTranslate.y=(-y+svge.currentTranslate.y)*(newScale/oldScale)
  svge.currentTranslate.x=(0+svge.currentTranslate.x)*(newScale/oldScale)
  svge.currentScale=newScale
  svge.currentTranslate.y+=y;
  svge.currentTranslate.x+=0;
}

function zoomSVG(amount) {
  const svge = svgResult.children[0];
  adjustSVGzoom(svge, amount);
  if (amount==0) {
    svge.currentTranslate.y = 0;
    svge.currentTranslate.x = 0;
  }
}

function addSVGZoomAndPan(svg){
  // From https://github.com/Holger-Will/SVGZoomAndPan/blob/master/zap.js
  svg.addEventListener("wheel",function(evt){
    if (evt.shiftKey) {
      // Only zoom while the shift key is pressed (to allow scrolling the page)
      var newScale
      if(evt.deltaY>0){newScale=svg.currentScale/1.1}
      if(evt.deltaY<0){newScale=svg.currentScale*1.1}
      var oldScale=svg.currentScale
       svg.currentTranslate.x=(-evt.offsetX+svg.currentTranslate.x)*(newScale/oldScale)
       svg.currentTranslate.y=(-evt.offsetY+svg.currentTranslate.y)*(newScale/oldScale)
       svg.currentScale=newScale
       svg.currentTranslate.x+=evt.offsetX
       svg.currentTranslate.y+=evt.offsetY
       var event = new Event('SVGZoom');
       svg.dispatchEvent(event);
       evt.preventDefault();  // Stop window from scrolling (update to zap.js)
     }
  } /*, {passive:true}*/)
  svg.addEventListener("mousedown",function(evt){
    if(!evt.shiftKey || evt.button==1){
      svg.classList.add("dragging")
      var ox=evt.offsetX
      var oy=evt.offsetY
      var otx=svg.currentTranslate.x
      var oty=svg.currentTranslate.y
      svg.addEventListener("mousemove",move)
      document.addEventListener("mouseup",out)
      var event = new Event('SVGScroll');
      svg.dispatchEvent(event)
      function out(evt){
        svg.removeEventListener("mousemove",move)
        document.removeEventListener("mouseup",out)
        svg.classList.remove("dragging")
        var event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
      function move(evt){
        svg.currentTranslate.x=otx+(evt.offsetX-ox)
        svg.currentTranslate.y=oty+(evt.offsetY-oy)
        var event = new Event('SVGScroll');
        svg.dispatchEvent(event)
      }
    }
  })
}

function rangeChange(id) {
  if (showJSON.checked) {
    slidersDiv.hidden = true;
    jsonDiv.hidden = false;
  } else {
    slidersDiv.hidden = false;
    jsonDiv.hidden = true;
  }
  updateValues();
}

function UpdateListener(id, event, foo) {
  var e = document.getElementById(id);
  if (e && !foo) {
    e.addEventListener(event, function(e) {
      updateValues();
    });
  } else
  if (e) {
    e.addEventListener(event, function(e) {
      foo(e);
    });
  }
}

UpdateListener('cbShowFar', 'input');
UpdateListener('cbShowFarMarks', 'input');
UpdateListener('cbShowFarExtra', 'input');
UpdateListener('cbShowNear', 'input');
UpdateListener('cbShowNearBase', 'input');
UpdateListener('cbShowGlyphs', 'input');
UpdateListener('cbShowCollisions', 'input');
UpdateListener('cbFarExtraMark', 'input');

UpdateListener('cbShowGids', 'input');
UpdateListener('cbShowGidNames', 'input');
UpdateListener('colourGlyph', 'input');
UpdateListener('colourSolid', 'input');
UpdateListener('showSliders', 'input', rangeChange);
UpdateListener('showJSON', 'input', rangeChange);

UpdateListener('debugInput', 'input', debugInputChange);
UpdateListener('debugOutput', 'dblclick', debugOutputDblClick);


var hbfcwl = null;
var api = {};
var fontFileName = '';
var checkMarkPath = undefined;

function openFontCompareWordListTool() {
  api = {};
  api.transfer = {};
  api.transfer.script = hbTest.script;
  api.transfer.language = hbTest.language;
  api.transfer.fontBlob = fontBlob;
  api.transfer.fontFileName = fontFileName;
  window.api = api;
  var wlfn = '';
  if (typeof(wordListFileName) !== 'undefined')
    api.transfer.wordListFileName = wordlistFilename;
  const xfer = api.transfer;
  xfer.wordList = hbTest.getWordList();
  if (!hbfcwl || hbfcwl.closed) {
    var hbfcwl_url;
    if (window.location.hostname === 'localhost')
      hbfcwl_url = '../font-compare-word-list/index.html';
    else
      hbfcwl_url = 'https://mattmatic.github.io/font-compare-word-list/index.html';
    hbfcwl = window.open(hbfcwl_url, 'mattmatic.font-compare-word-list')
  } else {
    hbfcwl.updateTransfer(api.transfer);
    hbfcwl.focus();
  }
}

function iterateGtable(gtable, theKey, outputset) {
  if (!gtable) return;
  const scriptTable = gtable.scriptTable;
  if (!scriptTable) return;
  if (!scriptTable[theKey]) return;
  for (const y of scriptTable[theKey]) {
    outputset.add(y);
  }
}

function mapToQuotes(list) {
  return '"'+[...list].sort().join('","')+'"';
}

function updateScriptLanguage() {
  const script = inputScript.value;
  const language = inputLanguage.value;

  const fontInfo = hbTest.fontInfo;
  inputScriptList.innerText = '(empty)';
  inputLanguageList.innerText = '(empty)';
  if (fontInfo) {
    if (fontInfo.scripts.size > 0) {
      inputScriptList.innerText = mapToQuotes(fontInfo.scripts);
    }
    let languages = fontInfo.languages;
    if (script !== '') {
      const theScript = script.toLowerCase();
      languages = new Set();
      iterateGtable(fontInfo.GSUB, theScript, languages);
      iterateGtable(fontInfo.GPOS, theScript, languages);      
    }
    if (languages.size > 0) {
      inputLanguageList.innerText = mapToQuotes(languages);
    }
    // features too
  }

  hbTest.setScriptLanguage(script, language);
  updateValues();
}

function copyGlyphNames() {
  let max = hbTest.otFont?.glyphs?.length;
  let txt = `Glyph Data: ${hbTest?.fontName?.fullName}, ${hbTest?.fontName?.version}\r\n\r\n`;
  let glyphSet = new Set();
  for (const [key, value] of Object.entries(hbTest.glyphValues)) {
    glyphSet.add(Number(key));
  }
  for (let i=0; i<max; i++) {
    let name = hbTest.getGlyphName(i);
    if (!name) name = '';
    txt += `${i}\t${name}`;
    if (!glyphSet.has(i)) {
      txt += `\t*`;
    }
    txt += '\r\n';
  }
  navigator.clipboard.writeText(txt);
}

function debugOutputText(txt) {
  debugOutput.value = txt;
}

function debugOutputError(err) {
  debugOutputText('ERROR:'+err);
}

function debugGlyphNames() {
  let max = hbTest.otFont?.glyphs?.length;
  let txt = `Glyph Data: ${hbTest?.fontName?.fullName}, ${hbTest?.fontName?.version}\r\n\r\n`;
  let fieldSet = new Set();
  for (const [key, value] of Object.entries(hbTest.glyphValues)) {
    fieldSet.add(Number(key));
  }
  let overlapSet = new Set();
  if (hbTest.overlaps) {
    hbTest.overlaps.forEach((v,i)=> { v.forEach((v,i)=>{overlapSet.add(v);}); });
  }
  let barSet = new Set();
  if (hbTest.bar) {
    hbTest.bar.gids.forEach((v,i)=> { barSet.add(v); });
  }

  for (let i=0; i<max; i++) {
    let name = hbTest.getGlyphName(i);
    if (!name) name = '';
    txt += `${i}\t`;
    txt += fieldSet.has(i)   ? 'f' : ' ';
    txt += overlapSet.has(i) ? 'o' : ' ';
    txt += barSet.has(i)     ? 'b' : ' ';
    txt += `\t${name}`;
    txt += '\r\n';
  }
  debugOutputText(txt);
}

function debugGIDs() {
  const gid = debugInput.value;
  if (!gid) {
    debugOutputError('!Need a GID number or name!');
    return;
  }
  let txt = `"${gid}"\r\n`;
  let count = 0;
  const hasLetters = String(gid).search(/[A-Za-z\{\}\$\.]/) >= 0;
  try {
    processRangeInteger(gid, hbTest.groups,
      function (g) {
        const name = hbTest.getGlyphName(g);
        txt += `  ${g}\t${name || ''}\r\n`;
        count++;
      });
    //console.log(`"${gid}" ->\r\n${txt}`);
    txt = `Count: ${count}\r\n` + txt;
  } catch(e) {
    debugOutputError(e.message);
    return;
  }
  debugOutputText(txt);
}

function debugGroup() {
  const groupName = debugInput.value;
  let countGlyph = 0;
  let countGroup = 0;
  let txt = '';
  for (let [key, group] of Object.entries(hbTest?.groups)) {
    let thisGroup = ((groupName.length == 0) || (groupName == key));
    if (!thisGroup) {
      // Check to see if the `groupName` is a glyph name...
      for (let vv of group) {
        const name = hbTest.getGlyphName(vv);
        if ((name == groupName) || (vv == parseInt(groupName))) {
          thisGroup = true;
          break;
        }
      }
    }
    if (thisGroup) {
      countGroup++;
      txt += `#${countGroup}:"${key}" => '${group.src}'\r\n`;      
      for (let vv of group) {
        countGlyph++;
        const name = hbTest.getGlyphName(vv);
        txt += `  ${vv}\t${name || ''}\r\n`;
      }
      txt += '\r\n\r\n';
    }
  };
  txt = `"${groupName}"\r\nGroups:${countGroup}, Glyphs:${countGlyph}\r\n` + txt;
  debugOutputText(txt);
}

function debugGroups() {
  const groups = hbTest?.groups;
  if (!groups) {
    debugOutputError('!No groups defined');
    return;
  }
  let txt = '';
  let count = 0;
  for (let key in groups) {
    txt += `${key}\r\n`;
    count++;
  }
  debugOutputText(txt);
}

function debugOverlaps() {
  let gid = debugInput.value;
  if (!hbTest.overlaps) {
    debugOutputError('!No overlaps defined.');
    return;
  }
  // Check if `gid` is a glyph name
  const gn = hbTest.getGidFromName(gid);
  if (gn)
    gid = gn;
  else
    gid = Number(gid);

  let count = 0;
  let output = '';
  const max = hbTest.overlaps.length;
  for (let i=0; i<max; i++) {
    const set = hbTest.overlaps[i];
    if (!gid || set.includes(gid)) {
      count++;
      let txt = '';
      set.forEach( function(v) {
        const name = hbTest.getGlyphName(v);
        txt += `  ${v}\t${name || ''}\r\n`;
      });
      output += `#${i}: '${set.src}'\r\n${txt}\r\n\r\n`;
    }
  }
  output = `"${debugInput.value}"\r\nCount:${count}\r\n` + output;
  debugOutputText(output);
}

function debugBar() {
  const bar = hbTest.bar;
  if (!bar) {
    debugOutputError('!No bar defined');
    return;
  }
  let txt = '';
  let count = 0;
  const max = bar.gids.length;
  for (let i=0; i<max; i++) {
    const g = bar.gids[i];
    const name = hbTest.getGlyphName(g);
    txt += `  ${g}\t${name || ''}\r\n`;
    count++;
  }
  debugOutputText(`Bar gids:\r\n${txt}`);
}

function debugCopy() {
  navigator.clipboard.writeText(debugOutput.value);
}

function debugInputChange(e) {
  const txt = debugInput.value;
  debugJson.innerText = JSON.stringify(txt);
}

function debugOutputDblClick(e) {
  const txt = debugOutput.value;
  let ss = debugOutput.selectionStart;
  let se = debugOutput.selectionEnd;
  const max = txt.length;
  const isDelim = ' \t,\'"';
  const isCrLf  = '\r\n';
  while (se > ss) {
    const ch = txt.charAt(se-1);
    if (!isDelim.includes(ch) && !isCrLf.includes(ch)) break;
    se--;
  }
  while (ss > 0) {
    const ch = txt.charAt(ss);
    if (isDelim.includes(ch)) {
      ss++;
      break;
    }
    if (isCrLf.includes(ch)) {
      ss++;
      break;
    }
    ss--;
  }
  while (se < max) {
    const ch = txt.charAt(se);
    if (isDelim.includes(ch)) {
      break;
    }
    if (isCrLf.includes(ch)) {
      break;
    }
    se++;
  }
  debugOutput.selectionStart = ss;
  debugOutput.selectionEnd   = se;
  debugInput.value = txt.slice(ss, se);
  debugInputChange();
}

</script>
<script type='module'>
"use strict";

import Clipper2ZFactory from "./js/clipper2z.js"
import Clipper2ZUtilsFactory from './js/clipper2z-utils.js';
import * as opentype from './js/opentype.min.mjs';
import Layout from './js/opentype.layout.gdef.mjs';
import JSON5 from './js/json5.index.min.mjs'

const promises = [
      Clipper2ZFactory(),
      Clipper2ZUtilsFactory(),
      createHarfBuzz()
    ];

let harfBuzzModule;
let Clipper2Z;
let Clipper2ZUtils;

Promise.all(promises).then(([aClipper2Z, aClipper2ZUtils, aharfBuzzModule]) => {
  Clipper2Z = aClipper2Z;
  Clipper2ZUtils = aClipper2ZUtils;

  harfBuzzModule = aharfBuzzModule;
  window.hb = hbjs(harfBuzzModule);
  // -v-v-v- DEBUG: make these available outside the module
  window.Clipper2Z = Clipper2Z;
  window.Clipper2ZUtils = Clipper2ZUtils;
  // -^-^-^-
  onResourcesLoaded();
});

function loadTheFont(blob) {
  window.fontBlob = blob;
  hbTest.setFontBlob(blob);
  updateScriptLanguage();
  if (hbTest.haveGlyphNames) {
    cbShowGidNames.disabled = false;
  } else {
    cbShowGidNames.disabled = true;
  }
  fontInfo.innerHTML = hbTest.fileDescription;
  disableDebugButtons();
}

function onResourcesLoaded() {
  var fontName = 'samples/Gulzar-Regular-1.002.ttf';
  //var fontName = 'samples/NotoSansDevanagari-Regular.ttf';
  fetch(fontName).then(function (res) {
    return res.arrayBuffer();
  }).then(function (blob) { // can be used without our wrapper
    hbTest.setBase(baseNear.value, baseFar.value);
    //inputText.value = "\u0631\u06cc\u0644\u062c\u06cc\u0648";
    //inputText.value = "\u063a\u06cc\u0631\u0646\u0641\u0639";
    //inputText.value = "\u062a\u0644";
    inputText.value = "\u0626\u0626\u0632\u0626\u06cc"; //Urdu
    //inputText.value = "\u0915\u094b\u0908\u0020\u0938\u0932\u093e\u0939\u0020\u0939\u0948"
    loadTheFont(new Uint8Array(blob));
    updateValues();
    acquireFontAndLists(window.opener);
  });
}

var drawFuncsPtr = null;
var haveDrawnPaths = 0;

function isExists(v) {
  if ((typeof(v) === 'object') && (v === null)) return false;
  return typeof(v) !== 'undefined';
}

function isAssigned(obj) {
  if (typeof obj === 'undefined') return false;
  if (obj === null) return false;
  return true;
}

function processGlyphName(txt, func) {
  /* -- old style
  if (txt.startsWith('.')) {
    // Allow for search anywhere
    txt = txt.substr(1);
  } else {
    txt = '^'+txt;  // Starts with
  }
  const endsWithDigit = new RegExp('[0-9]$');
  if (endsWithDigit.test(txt)) {
    txt += '$';
  }
  */

  //------NEW FORMAT 2025-11-21
  //---------------------------
  // Like DOS filename wildcards, but with regexp option
  // `/regexp/`
  // `start`
  // `start*end`
  // `start*middle*`
  // `*end`
  // `*middle*`
  // And ? is single character
  let exp = '';
  const specials = '*+?{}[]\\$^:,-'
  if (txt.startsWith('/') && txt.endsWith('/')) {
    // regexp
    exp = txt.slice(1, -1);
  } else {
    // Convert DOS style...
    let hasAsterisk = false;
    let endAnchor = false;
    if (txt.endsWith('$')) {
      // Partial grep syntax - to anchor to the end
      endAnchor = true;
      txt = txt.slice(0, txt.length-1);
    }
    if (txt.startsWith('*')) {
      hasAsterisk = true;
      txt = txt.slice(1);
    } else {
      exp += '^'; // Anchor at the start
    }
    const len = txt.length;
    for (let i=0; i<len; i++) {
      const ch = txt[i];
      if (ch == '*') {
        exp += '.*'; // 0 or more of any character
        hasAsterisk = true;
      } else
      if (ch == '?') {
        exp += '.';  // Any character
      } else
      if (ch == '.') {
        exp += '[.]'; // Literal
      } else 
      if (specials.includes(ch)) {
        exp += '\\x'+ch.charCodeAt(0).toString(16).padStart(2,'0');
      } else {
        exp += ch;
      }
    }
    if ((hasAsterisk && !txt.endsWith('*')) || endAnchor) {
      exp += '$'; // anchor to the end
    }
  }

  const re = new RegExp(exp);
  const max = hbTest.otFont?.glyphs?.length;
  let found = false;
  for (let i=0; i<max; i++) {
    const name = hbTest.getGlyphName(i);
    if (re.test(name)) {
      found = true;
      func(i, name);
    }
  }
  return found;
}

function processRangeInteger(txt, groupSet, func) {
  var count = 0;
  if (typeof txt === 'number') {
    func(txt);
    return 1;
  }
  if (typeof txt !== 'string') {
    throw new Error('Group/Range error "'+v+'"');
    return 0;
  }
  const hasLetters = new RegExp('[A-Za-z]');
  var sets = txt.split(',');
  for (let set of sets) {
    let range;
    if (hasLetters.test(set)) {
      range = [set];
    } else {
      range = set.split('-');
    }
    if (range.length === 1) {
      const v = range[0];
      if (!isNaN(v)) {
        const gid = parseInt(v);
        func(gid);
        count++;        
      } else
      if (groupSet && groupSet[v]) {
        for (let vv of groupSet[v]) {
          func(vv);
          count++;
        }
      } else
      if (processGlyphName(v, func)) {
        // Found!
      } else
      {
        throw new Error('Group/Range error "'+v+'"');
      }
    }
    else {
      // TODO(maybe?): handle ranges of glyph names     
      const rangeFrom = parseInt(range[0]);
      const rangeTo = parseInt(range[1]);
      if (rangeTo <= rangeFrom) {
        throw new Error('Range error "'+set+'"');
      }
      for (let v = rangeFrom; v<=rangeTo; v++) {
        func(v);
        count++;
      }
    }
  }
  return count;
}

// Class to wrap up a Clipper2 Paths64 and Bounding Box
// and provide some basic optimisation calculations
class CPaths64 {
  constructor() {
    this.paths64 = new Clipper2Z.Paths64();
    this.bbox = {x:{min:NaN, max:NaN},y:{min:NaN, max:NaN},width:0,height:0};
  }
  destroy() {
    this.freePath();
  }
  freePath() {
    if (isAssigned(this.paths64)) {
      this.paths64.clear();
      this.paths64.delete();
      delete this.paths64;
    }
  }
  // Iterate through the paths and each path to find bounding box
  findBoundingBox() {
    this.bbox = {x:{}, y:{}}
    const size = this.paths64.size();
    for (let i=0; i<size; i++) {
      const path = this.paths64.get(i);
      const sizep = path.size();
      for (let ii=0; ii<sizep; ii++) {
        const point = path.get(ii);
        const x = Number(point.x);
        const y = Number(point.y);
        if (!isAssigned(this.bbox.x.min) || (x < this.bbox.x.min)) this.bbox.x.min = x;
        if (!isAssigned(this.bbox.x.max) || (x > this.bbox.x.max)) this.bbox.x.max = x;
        if (!isAssigned(this.bbox.y.min) || (y < this.bbox.y.min)) this.bbox.y.min = y;
        if (!isAssigned(this.bbox.y.max) || (y > this.bbox.y.max)) this.bbox.y.max = y;
        point.delete(); //????
      }
      path.delete();
    }
    this.updateWidthHeight();
  }
  // Update just the bounding box width and height
  updateWidthHeight() {
    this.bbox.width  = (this.bbox.x.max - this.bbox.x.min);
    this.bbox.height = (this.bbox.y.max - this.bbox.y.min);
  }
  // Return the bound box
  getBoundingBox() {
    const result = bbox;
    return result;
  }
  // Iterate through all paths and remove any that are smaller than `minArea`
  removeSmallAreas(minArea) {
    const { AreaPath64, Paths64 } = Clipper2Z;
    const count = this.paths64.size();
    var output = new Paths64();
    for (let i=0; i<count;i++) {
      const path = this.paths64.get(i);
      const area = Math.abs(AreaPath64(path));
      if (area >= minArea) {
        output.push_back(path);
      } else {
        path.delete();
      }
    }
    this.freePath();
    this.setPaths64(output);
    this.findBoundingBox(); // Might have changed if small areas were on the outside edges
  }
  // Set this CPaths64 to a Clipper2Z Paths64 value, updating the bounding box
  setPaths64(ps64, dontFindBoundingBox) {
    if (isAssigned(this.paths64) && (ps64 != this.paths64)) {
      this.freePath();
    }
    this.paths64 = ps64;
    if (!dontFindBoundingBox) this.findBoundingBox();
  }
  // Translate this path by (oxi, oyi) and return a new CPaths64
  translateToNewCPaths64(oxi, oyi) {
    oxi = Number(oxi);
    oyi = Number(oyi);
    const { TranslatePaths64 } = Clipper2Z;
    var result = new CPaths64();
    result.freePath();
    result.setPaths64(TranslatePaths64(this.paths64, oxi, oyi), true);
    result.bbox.x.min = this.bbox.x.min + oxi;
    result.bbox.x.max = this.bbox.x.max + oxi;
    result.bbox.y.min = this.bbox.y.min + oyi;
    result.bbox.y.max = this.bbox.y.max + oyi;
    return result;
  }
  duplicatePath() {
    const { TranslatePaths64 } = Clipper2Z;
    let result = new CPaths64();
    result.setPaths64(TranslatePaths64(this.paths64, 0, 0), true);
    return result;
  }
  // Inflate this path by `idelta` and return a new CPaths64 object.
  // settings.jointype = JoinType.Miter
  // settings.mitreLimit = 25
  // settings.arcTolerance = 0.1
  // settings.simplifyFactor = 0.5
  inflateToNewCPaths64(idelta, settings) {
    const { MakePath64, Paths64, InflatePaths64, SimplifyPaths64, JoinType, EndType } = Clipper2Z;
    var result = new CPaths64();
    settings = settings || {};
    if (!isExists(settings.jointype)) settings.jointype = /*JoinType.Miter; */ JoinType.Round;
    if (!isExists(settings.mitreLimit)) settings.mitreLimit = 25; //idelta;// * idelta; //25
    if (!isExists(settings.arcTolerance)) settings.arcTolerance = 0.1;
    if (!isExists(settings.simplifyFactor)) settings.simplifyFactor = 0.1;
    var newpaths64 = InflatePaths64(this.paths64, idelta, settings.jointype, EndType.Polygon, settings.mitreLimit, settings.arcTolerance);
    if (settings.simplifyFactor > 0) {
      var oldpaths64 = newpaths64;
      newpaths64 = SimplifyPaths64(oldpaths64, settings.simplifyFactor);
      oldpaths64.clear();
      oldpaths64.delete();
    }
    result.setPaths64(newpaths64);
    //--//this.removeSmallAreas(idelta * idelta);
    return result;
  }
  // Check whether this and `cp` are far away (using the bounding boxes)
  isFarAway(cp) {
    // Comparing bounding boxes to optimise calculations
    if (cp.bbox.x.min > this.bbox.x.max) return true;
    if (cp.bbox.x.max < this.bbox.x.min) return true;
    if (cp.bbox.y.min > this.bbox.y.max) return true;
    if (cp.bbox.y.max < this.bbox.y.min) return true;
    return false; // _might_ collide. Need to do geometry
  }
  // Check for collisions between this and `cp`
  // Returns null if no collision.
  // Otherwise returns a new CPaths64 with the intersection
  collisionCPath(cp) {
    const { Intersect64, Union64FillRule, FillRule } = Clipper2Z;
    if (this.isFarAway(cp)) {
      return null;
    }
    var intersect = Intersect64(this.paths64, cp.paths64, FillRule.NonZero);
    if (intersect.size() == 0) {
      intersect.clear();
      intersect.delete();
      return null;
    }
    var result = new CPaths64();
    result.setPaths64(intersect);
    return result;
  }
  // Meld `cp` into this CPaths64
  unionWith(cp) {
    const { Union64, FillRule, Union64FillRule } = Clipper2Z;
    var res = Union64(this.paths64, cp.paths64, FillRule.NonZero);
    this.freePath();
    this.setPaths64(res, true);
    if (cp.bbox.x.min < this.bbox.x.min) this.bbox.x.min = cp.bbox.x.min;
    if (cp.bbox.x.max > this.bbox.x.max) this.bbox.x.max = cp.bbox.x.max;
    if (cp.bbox.y.min < this.bbox.y.min) this.bbox.y.min = cp.bbox.y.min;
    if (cp.bbox.y.max > this.bbox.y.max) this.bbox.y.max = cp.bbox.y.max;
    this.updateWidthHeight();
  }
  xorWith(cp) {
    const { Xor64, FillRule, Union64FillRule } = Clipper2Z;
    var res = Xor64(this.paths64, cp.paths64, FillRule.NonZero);
    this.freePath();
    this.setPaths64(res);
  }
  subtract(cp) {
    const { Difference64, FillRule } = Clipper2Z;
    var res = Difference64(this.paths64, cp.paths64, FillRule.NonZero);
    this.freePath();
    this.setPaths64(res);
  }
  // Count the positive paths in the set
  // (Used for finding 'far' glyphs)
  countIslands() {
    const { IsPositive64 } = Clipper2Z;
    const size = this.paths64.size();
    var count = 0;
    for (let i=0;i<size;i++) {
      const path = this.paths64.get(i);
      if (IsPositive64(path)) count++;
      path.delete();
    }
    return count;
  }
  // Methods for rendering the original glyph to create the paths
  // Add a single point to the set of points
  // NOTE: updates bounding box
  addPoint(ix, iy) {  // Integer values!
    this.points = this.points || [];
    this.points.push(ix, iy);
    this.last = {x:ix, y:iy};
    if (!(this.bbox.x.min) || (ix < this.bbox.x.min)) this.bbox.x.min = ix;
    if (!(this.bbox.x.max) || (ix > this.bbox.x.max)) this.bbox.x.max = ix;
    if (!(this.bbox.y.min) || (iy < this.bbox.y.min)) this.bbox.y.min = iy;
    if (!(this.bbox.y.max) || (iy > this.bbox.y.max)) this.bbox.y.max = iy;
  }
  // Close the path, back to the beginning, and add to the paths.
  // NOTE: bounding box already updated with `addPoint`
  closePath() {
    const { MakePath64, Paths64 } = Clipper2Z;
    if (this.points.length > 0) {
      if (!isAssigned(this.paths64)) {
        this.paths64 = new Paths64();
      }
      this.points.push(this.points[0], this.points[1]); // Close the path back to the beginning
      this.paths64.push_back(MakePath64(this.points));
      delete this.points;
      this.last = {};
      this.updateWidthHeight();
    }
  }
}

class GlyphSet {
  constructor(gid, cpaths64) {
    this.gid = gid;
    this.paths = {};
    this.paths.glyph = cpaths64;
  }
  destroy() {
    // Iterate through this.paths and destroy each
    for (let id in this.paths) {
      this.paths[id].destroy();
    }
  }
  add(id, cpaths64) {
    if (this.paths[id]) this.paths[id].destroy();
    this.paths[id] = cpaths64;
  }
  addInflated(id, amount) {
    let p = this.paths.glyph.inflateToNewCPaths64(amount);
    this.add(id, p);
    return p;
  }
  getGlyphNewCPaths64() {
    let p = this.paths.glyph.inflateToNewCPaths64(0);
    return p;
  }
  path(id) {
    if (id == 'glyph') {
      return this.paths.glyph;
    }
    let p = this.paths[id];
    return p;
  }
  glyph() {
    return this.paths.glyph;
  }
  translateToNewGlyphSet(x, y) {
    let res = new GlyphSet(this.gid, undefined);
    for (let id in this.paths) {
      const p = this.paths[id];
      res.add(id, p.translateToNewCPaths64(x, y));
    }
    return res;
  }
  has(id) {
    return typeof this.paths[id] === 'object';
  }
}

function fillOtInfoTables(fontInfo) {
  fontInfo.scripts = new Set();
  fontInfo.languages = new Set();
  fontInfo.features = new Set();

  let doGtable = function(t) {
    if (!t) return;
    if (t.scriptTable) {
      for (const key in t.scriptTable) {
        fontInfo.scripts.add(key);
        for (const val of t.scriptTable[key]) {
          fontInfo.languages.add(val);
        }
      }
    }
    if (t.featureListTable) {
      for (const val of t.featureListTable) {
        fontInfo.features.add(val);
      }
    }
  }
  doGtable(fontInfo.GSUB);
  doGtable(fontInfo.GPOS);
}

class HarfBuzzForceFieldClass {
  constructor() {
    this.glyphs = {};
    this.glyphValues = {};
    this.svgData = '';
    this.clearDefaults();
    this.setFarValues([10,25,50]);
    this.farValueOk = false;
    this.groups = {};
  }
  clearDefaults() {    
    this.defaults = {};
    this.defaults.clusterOverlap = false;  // Take this is as default
  }
  destroy() {
    this.freeFont();
    delete(this.fontBlob);
  }
  freeFontBlob() {
    this.freeFont();
    delete(this.fontBlob);
  }
  freeFont() {
    if (isAssigned(this.font)) { this.font.destroy(); delete(this.font); }
    if (isAssigned(this.face)) { this.face.destroy(); delete(this.face); }
    if (isAssigned(this.blob)) { this.blob.destroy(); delete(this.blob); }
    //this.glyphs = {};
    this.freeGlyphCache();
    this.glyphValues = {};
    delete(this.otLayout);
    delete(this.otFont);
  }
  freeGlyphValues() {
    this.glyphValues = {};
  }
  freeGlyphCache() {
    if (!isAssigned(this.glyphs)) return;
    if (isAssigned(this.glyphs) && (this.glyphs.length>0)) {
      Object.keys(this.glyphs).forEach(function(k) {
        const e = this.glyphs[k];
        e.destroy();
      });
    }
    this.glyphs = {};
  }
  setScriptLanguage(script, language) {
    this.script = script;
    this.language = language;
  }
  clearScriptLanguage() {
    this.script = null;
    this.language = null;
  }
  setFeatures(features) {
    this.features = features;
  }
  clearFeatures() {
    this.features = null;
  }
  setFontBlob(fb) {
    this.freeFont();
    this.fontBlob = fb;
    if (!isAssigned(fb)) return;
    const otInfo = OTInfo.parse(fb);
    this.fontInfo = otInfo[0];
    fillOtInfoTables(this.fontInfo);
    this.fontName = this.fontInfo.name;
    this.fileDescription = this.fontName.fullName + '</br>' + this.fontName.version;

    this.blob = hb.createBlob(this.fontBlob);
    this.face = hb.createFace(this.blob, 0);
    this.font = hb.createFont(this.face);
    this.otFont = opentype.parse(fb);
    this.otLayout = new Layout(this.otFont, 'GPOS');

    this.haveGlyphNames = false;
    const max = this.otFont?.glyphs?.length;
    for (let i=0;i<max;i++) {
      if (this.getGlyphName(i)) {
        this.haveGlyphNames = true;
        break;
      }
    }
  }
  getGlyphClass(gid) {
    return this.otLayout.getGlyphClass(this.otFont.tables.gdef.classDef, gid);
  }
  getGlyphName(gid) {
    const glyphData = this.otFont?.glyphs?.get(gid);
    if (!glyphData) return undefined;
    return glyphData.name;
  }
  getGidFromName(name) {
    const max = hbTest.otFont?.glyphs?.length;
    let found = false;
    for (let i=0; i<max; i++) {
      const gn = this.getGlyphName(i);
      if (name == gn) {
        return i;
      }
    }
    return undefined;
  }
  isMarkClass(gid) {
    return (this.getGlyphClass(gid) === 3);
  }
  setBase(near, far) {
    if ((near != this.baseNear) || (far != this.baseFar)) {
      this.freeGlyphCache();
    }
    this.baseNear = near;
    this.baseFar  = far;
  }
  setMark(near, nearBase, far) {
    if ((near != this.markNear) ||
        (far  != this.markFar) ||
        (nearBase != this.markNearBase)) {
      this.freeGlyphCache();
    }
    this.markNear = near;
    this.markNearBase = nearBase;
    this.markFar = far;
  }
  setGlyphValues(gid, far, near, nearBase, clusterOverlap) {
    if (typeof clusterOverlap === 'undefined') {
      clusterOverlap = this.defaults.clusterOverlap;
    }
    this.glyphValues[gid] = {
      far:far,
      near:near,
      nearBase:nearBase,
      clusterOverlap: clusterOverlap,
    };
  }
  getGlyphValues(gid) {
    const isMark = (this.getGlyphClass(gid) === 3);
    const gb = this.glyphValues[gid];
    var near = this.baseNear || 30;
    var far  = this.baseFar || 90;
    var nearBase = null;
    var clusterOverlap = undefined;

    if (isMark) {
      near = this.markNear || 30;
      far  = this.markFar || 90;
      nearBase = this.markNearBase || 1;
    }
    if (isAssigned(gb)) {
      var toValue = function(txt, v) {
        if (txt ===  null) return v;
        if (typeof(txt) === 'undefined') return v;
        if (typeof(txt) !== 'string') return txt;
        const n = parseInt(txt, 10);
        if (txt.includes('%')) {
          return (v * n) / 100.0;
        }
        if (isNaN(txt)) return v;
        return n;
      }
      far = toValue(gb.far, far);
      near = toValue(gb.near, near);
      if (isMark)
        nearBase = toValue(gb.nearBase, nearBase);
      clusterOverlap = gb.clusterOverlap;
    }
    return {
      far: far,
      near: near,
      nearBase: nearBase,
      clusterOverlap: clusterOverlap,
    };
  }

  //----------------------------------------------------------------------
  // Converts the glyph drawing to an array of point arrays compatible with Clipper2
  // The array is [x0,y0, x1,y1, etc]
  // Also calculates the bound box in `bbox` with width and height
  // NOTE: Cubic Bezier curve flattening not tested yet!!
  glyphToPolyline(glyphId) {
    if (!isAssigned(this.glyphs[glyphId])) {
      var ptr = this.font.ptr;
      var exports = harfBuzzModule.wasmExports;
      var addFunction = harfBuzzModule.addFunction;
      /*
      var lastXY = {};
      var firstXY = {};
      */
      var paths = [];
      var points = [];
      var bbox = {};
      const { MakePath64, Paths64, InflatePaths64, SimplifyPaths64, JoinType, EndType } = Clipper2Z;
      var cpaths = new Paths64();

      var cpaths64 = new CPaths64();
      var updatePoint = function(x, y) {
        x = Math.round(x);
        y = Math.round(y);
        cpaths64.addPoint(x, y);
        /*
        points.push(x, y);
        if (!bbox.min) bbox.min = {};
        if (!bbox.max) bbox.max = {};
        if (!bbox.min.x || (x < bbox.min.x)) bbox.min.x = x;
        if (!bbox.min.y || (y < bbox.min.y)) bbox.min.y = y;
        if (!bbox.max.x || (x > bbox.max.x)) bbox.max.x = x;
        if (!bbox.max.y || (y > bbox.max.y)) bbox.max.y = y;
        lastXY = {x:x, y:y};
        */
      }
      if (!drawFuncsPtr) {
        var moveTo = function (dfuncs, draw_data, draw_state, to_x, to_y, user_data) {
          //pathBuffer += `M${to_x},${to_y}`;
          // Starting a new set
          updatePoint(to_x, to_y);
        }
        var lineTo = function (dfuncs, draw_data, draw_state, to_x, to_y, user_data) {
          //pathBuffer += `L${to_x},${to_y}`;
          updatePoint(to_x, to_y);
        }
        var cubicTo = function (dfuncs, draw_data, draw_state, c1_x, c1_y, c2_x, c2_y, to_x, to_y, user_data) {
          //pathBuffer += `C${c1_x},${c1_y} ${c2_x},${c2_y} ${to_x},${to_y}`;
          // Flatten Cubic Bezier to Lines...
          const last = cpaths64.last;
          let c = {p0: {x:last.x, y:last.y}, p1:{x:c1_x, y:c1_y}, p2:{x:c2_x, y:c2_y}, p3:{x:to_x, y:to_y}};
          let qs = cubicBezToQuadratics(c, quadBezState.tolerance); // Tolerance???
          for (let q of qs) {
            let ts = quadBezFlatten(q);
            for (let t of ts) {
              const {x,y} = evalQuadBez(q, t);
              updatePoint(x, y);
            }
          }
          updatePoint(to_x, to_y);
        }
        var quadTo = function (dfuncs, draw_data, draw_state, c_x, c_y, to_x, to_y, user_data) {
          //pathBuffer += `Q${c_x},${c_y} ${to_x},${to_y}`;
          // Flatten Quadratic Bezier to Lines...
          const last = cpaths64.last;
          let q = { p0: {x:last.x, y:last.y}, p1: {x:c_x, y:c_y}, p2: {x:to_x, y:to_y}};
          let ts = quadBezFlatten(q);
          for (let t of ts) {
            const {x, y} = evalQuadBez(q, t);
            updatePoint(x, y);
          }
        }
        var closePath = function (dfuncs, draw_data, draw_state, user_data) {
          cpaths64.closePath();
        }

        var moveToPtr = addFunction(moveTo, 'viiiffi');
        var lineToPtr = addFunction(lineTo, 'viiiffi');
        var cubicToPtr = addFunction(cubicTo, 'viiiffffffi');
        var quadToPtr = addFunction(quadTo, 'viiiffffi');
        var closePathPtr = addFunction(closePath, 'viiii');
        var drawFuncsPtr = exports.hb_draw_funcs_create();
        exports.hb_draw_funcs_set_move_to_func(drawFuncsPtr, moveToPtr, 0, 0);
        exports.hb_draw_funcs_set_line_to_func(drawFuncsPtr, lineToPtr, 0, 0);
        exports.hb_draw_funcs_set_cubic_to_func(drawFuncsPtr, cubicToPtr, 0, 0);
        exports.hb_draw_funcs_set_quadratic_to_func(drawFuncsPtr, quadToPtr, 0, 0);
        exports.hb_draw_funcs_set_close_path_func(drawFuncsPtr, closePathPtr, 0, 0);
      }

      var pathBuffer = "";
      exports.hb_font_draw_glyph(ptr, glyphId, drawFuncsPtr, 0);
      if (bbox.max && bbox.min) {
        bbox.width = bbox.max.x - bbox.min.x;
        bbox.height = bbox.max.y - bbox.min.y;
      } else {
        bbox.width = 0;
        bbox.height = 0;
      }
      paths.bbox = bbox;
      // Clipper2 Paths
      paths.cpaths = cpaths64;
      const mitreLimit = 25;
      const arcTolerance = 0;

      const gb = this.getGlyphValues(glyphId);
      const nearInflate = gb.near;  // Overlaps = too close
      const farInflate  = gb.far;   // No Overlaps = too far

      let gs = new GlyphSet(glyphId, cpaths64);
      gs.addInflated('near', nearInflate);
      gs.addInflated('far',  farInflate);
      
      for (let i=0;i<this.farValues.length;i++) {
        const p = this.farValues[i];
        gs.addInflated(`far${p}`, farInflate * (1 + p/100.0)); // 110% to 190%
      }
      
      if ((typeof(gb.nearBase) !== 'undefined') && (gb.nearBase !== null)) {
        gs.addInflated('nearBase',  gb.nearBase);
      }
      if (this.glyphInBars(glyphId)) {
        const bar = hbTest.getBarCPath();
        let p = gs.getGlyphNewCPaths64();
        p.subtract(bar);
        let pi = p.inflateToNewCPaths64(nearInflate);
        p.setPaths64(pi.paths64);
        gs.add('nearBar', p);

        p = gs.getGlyphNewCPaths64();
        p.subtract(bar);
        pi = p.inflateToNewCPaths64(farInflate);
        p.setPaths64(pi.paths64);
        gs.add('farBar', p);
      }
      this.glyphs[glyphId] = gs; // Result cached in this object
    }
    return this.glyphs[glyphId];
  }
  drawSVGPath(p64, settings) {
    const size = p64.size();
    for (let i=0;i<size;i++) {
      const point = p64.get(i);
      const x= Number(point.x) *  1;
      const y= Number(point.y) * -1;
      if (i==0)
        this.svgData += `M${x},${y}`;
      else
        this.svgData += `L${x},${y}`;
      point.delete(); //??
    }
    this.svgData += 'z';
  }
  drawSVGPaths(ps64, settings) {
    if (!isAssigned(ps64)) return;
    settings = settings || {};
    if (!isExists(settings.mixBlendMode)) settings.mixBlendMode = 'normal';
    this.svgData += '<path ';
    if (settings.id) {
      this.svgData += `id="${settings.id}" `;
    }
    this.svgData += ' style="';
    if (isExists(settings.fillColor)) {
      if (!isExists(settings.fillOpacity)) settings.fillOpacity = 0.5;
      this.svgData += 'fill:'+settings.fillColor
                    +';fill-opacity:'+settings.fillOpacity
    } else {
      this.svgData += ';fill-opacity:0';
    }
    if (isExists(settings.strokeColor)) {
      if (!isExists(settings.strokeOpacity)) settings.strokeOpacity = 1.0;
      if (!isExists(settings.strokeWidth)) settings.strokeWidth = 2;
      this.svgData += ';stroke:'+settings.strokeColor
                    +';stroke-opacity:'+settings.strokeOpacity
                    +';stroke-width:'+settings.strokeWidth
                    +';stroke-linejoin=\'round\''
    }
    if (settings.mixBlendMode !== 'normal')
      this.svgData +=';mix-blend-mode:\''+settings.mixBlendMode+'\''

    this.svgData += '" d="';
    const size = ps64.size();
    for (let i=0;i<size;i++) {
      const path = ps64.get(i);
      this.drawSVGPath(path, settings);
      path.delete();
    }
    this.svgData += '"/>\r\n';
  }
  drawCPaths(cp, color, settings) {
    //if (cp) drawPaths(cp.paths64, color);
    if (!isAssigned(settings)) settings = {};
    if (color) settings.strokeColor = color;
    this.drawSVGPaths(cp.paths64, settings);
  }
  drawGlyphPaths(glyph, min, max) {
    if (max) drawPaths(max,     {fillColor:'#00c0c0'});
    if (glyph) drawPaths(glyph, {strokeColor:'#000000'});
    if (min) drawPaths(min,     {fillColor:'#00c020'});
  }
  drawCollisionPaths(col) {
    if (col) drawPaths(col,     {strokeColor:'#f04040',fillColor:'#f04040'});
  }
  startSVG() {
    this.svgData = '';
  }
  renderSVG() {
    const xmin = -250;
    const ymin = -1800;
    const height = 3000;
    const heightOut = 400;
    const width = (window.innerWidth) * height / heightOut * 0.95;
    var bbox = xmin + ' ' + ymin + ' ' +width + ' ' + height;
    this.svgData = '<svg xmlns="http://www.w3.org/2000/svg"'
      + ' height="400"'
      + ' viewBox="'+bbox+'">' +this.svgData+'</svg>';
    updateSvg(svgResult, this.svgData);
    addSVGZoomAndPan(svgResult.children[0]);
  }
  getWordList() {
    var res = [];
    const size = wordList.length;
    for (let i = 0; i<size; i++) {
      const we = wordList[i];
      res.push(
        {
          word: we.getWord(),
          checked: we.getChecked(),
          note: we.getNote(),
        }
        );
    }
    return res;
  }
  gidArrayExpand(gids) {
    // Expand using this.groups if needed
    let res = [];
    const size = gids.length;
    for (let i=0;i<size;i++) {
      const v = gids[i];
      if (typeof v === 'number')
        res.push(v);
      else
      if (typeof v === 'string') {
        const group = this.groups[v];
        if (group) {
          const size = group.length;
          for (let ii=0;ii<size;ii++) {
            const g = group[ii];            
            if (typeof g === 'number') {
              res.push(g);
            } else {
              throw new Error('Group "'+v+'" recursion not allowed!');
            }
          }
        } else
        if (processGlyphName(v, (gid) => {
          res.push(gid);
        })) {
          // we added at least one GID
        } else {
          // Missing group!
          throw new Error('Group "'+v+'" not found!');
        }
      }
    }
    return res;
  }
  setBar(barObject) {
    if (this?.bar?.cpaths) this.bar.cpaths64.destroy();
    this.bar = {};
    this.bar.area = barObject.area; // An array of either y1,y2 or x1,y1,x2,y2
    this.bar.gids = this.gidArrayExpand(barObject.gids); // A plain array of gids
    this.bar.far  = barObject.far;  // Whether to include the bar in the far 
    this.bar.src = String(barObject);

    if (this?.bar?.cpaths64)
      this.bar.cpaths64.destroy();
    let p = new CPaths64();
    for (let i in barObject.area) {
      const e = barObject.area[i];
      if (e.length == 2) {
        const y1 = e[0];
        const y2 = e[1];
        p.addPoint(-10000, y1);  
        p.addPoint(-10000, y1);
        p.addPoint( 10000, y1);
        p.addPoint( 10000, y2);
        p.addPoint(-10000, y2);
        p.closePath();
      } else
      if (e.length == 4) {
        const x1 = e[0];
        const y1 = e[1];
        const x2 = e[2];
        const y2 = e[3];
        p.addPoint(x1, y1);
        p.addPoint(x2, y1);
        p.addPoint(x2, y2);
        p.addPoint(x1, y2);
        p.closePath();
      }
    }
    this.bar.cpaths64 = p;
  }
  getBarCPath() {
    return this.bar.cpaths64;
  }
  glyphsInBars(gid1, gid2) {
    if (!this.bar) return false;
    if (!this.bar.gids) return false;
    return (this.bar.gids.includes(gid1) && this.bar.gids.includes(gid2));
  }
  glyphInBars(gid) {
    if (!this.bar) return false;
    if (!this.bar.gids) return false;
    return (this.bar.gids.includes(gid));
  }
  setOverlaps(overlapsArray) {
    this.overlaps = [];
    const size = overlapsArray.length;
    for (let i=0;i<size;i++) {
      const a = overlapsArray[i];
      let obj = this.gidArrayExpand(a);
      obj.src = String(a);
      this.overlaps.push(obj);
    }
  }
  glyphsOverlap(gid1, gid2) {
    if (!this.overlaps) return false;
    for (let set of this.overlaps) {
      if (set.includes(gid1) && set.includes(gid2)) {
        return true;
      }
    }
    return false;
  }
  clearGroups() {
    this.groups = {};    
  }
  setGroups(data) {
    this.clearGroups();
    const obj = this;
    Object.keys(data).forEach(function(k) {
      const v = data[k];
      const size = v.length;
      let group = [];
      for (let i=0; i<size;i++) {
        const gid = v[i];
        processRangeInteger(gid, null, function(g, n) {group.push(g);});
      }
      group.src = String(v);
      obj.groups[k] = group;
    });
  }
  getGroup(id) {
    return this.groups[id];
  }
  setFarValues(arr) {
    this.farValues = arr;
    // Sort descending
    this.farValues.sort(function(a,b) {
      if (a < b) return 1;
      if (a > b) return -1;
      return 0;
    });
  }
}

class CursivesSet {
  constructor() {
    this.sets = [];
  }
  findIndex(i) {
    var res = null;
    this.sets.find(function(e) {
      if (e.includes(i)) {
        res = e;
        return true;
      }
      return false;
    });
    return res;
  }
  addPair(p1, p2) {
    var e = this.findIndex(p1);
    if (e) {
      e.push(p2);
      return e;
    }
    e = this.findIndex(p2);
    if (e) {
      e.push(p1);
      return e;
    }
    e = [p1, p2];
    this.sets.push(e);
    return e;
  }
  findPair(p1, p2) {
    var e = this.findIndex(p1);
    if (e && e.includes(p2))
      return e;
    return null;
  }
  reverseIndices(count) {
    this.sets.forEach(function(e) {
      const size = e.length;
      for (let i=0;i<size;i++) {
        e[i] = count - e[i] - 1;
      }
    });
  }
}

class MarksSet {
  constructor() {
    this.sets = [];
  }
  findIndex(i) {
    var res = null;
    this.sets.find(function(e) {
      if (e.includes(i)) {
        res = e;
        return true;
      }
      return false;
    });
    return res;
  }
  addPair(p1, p2) {
    var e = this.findIndex(p1);
    if (e) {
      if (e[1] == p2) return e;
    }
    e = [p1, p2];
    this.sets.push(e);
    return e;
  }
  findEither(p1, p2) {
    // Find the MARK gid in either p1 or p2
    return this.sets.find((s) => (s[0] == p1) || (s[0] ==p2));
  }
  findBoth(p1, p2) {
    return this.sets.find((s) => (s.includes(p1) && s.includes(p2)));
  }
  findEitherBase(p1, p2) {
    var e = this.findIndex(p1);
    if (e) return e[1];
    if (p2) {
      e = this.findIndex(p2);
      if (e) return e[1];
    }
    return null;
  }
  reverseIndices(count) {
    this.sets.forEach(function(e) {
      const size = e.length;
      for (let i=0;i<size;i++) {
        e[i] = count - e[i] - 1;
      }
    });
  }
}


function shapeAndFindAttachments(font, buffer, features) {
  const exports = hb.hooks.exports;
  const addFunction = hb.hooks.addFunction;
  const removeFunction = hb.hooks.removeFunction;
  const utf8Decoder = hb.hooks.utf8Decoder;
  const Module = hb.hooks.Module;

  var data = {};
  data.cursives = new CursivesSet();
  data.marks = new MarksSet();

  var pullGlyphIndices = function(txt) {
    const parts = / at ([\d]+).* at ([\d]+)/.exec(txt);
    if (!parts) return null;
    return parts.slice(1).map((p) => parseInt(p, 10));
  }
  var traceFunc = function(bufferPtr, fontPtr, messagePtr, user_data) {
    var message = utf8Decoder.decode(Module.HEAPU8.subarray(messagePtr, Module.HEAPU8.indexOf(0, messagePtr)));
    if (message.startsWith('cursive attached')) {
      const gis = pullGlyphIndices(message);
      data.cursives.addPair(gis[0], gis[1]);
    }
    if (message.startsWith('attached mark')) {
      const gis = pullGlyphIndices(message);
      data.marks.addPair(gis[0], gis[1]);
    }
    return 1;
  }

  var traceFuncPtr = addFunction(traceFunc, 'iiiii');
  exports.hb_buffer_set_message_func(buffer.ptr, traceFuncPtr, 0, 0);
  hb.shape(font, buffer, features, 0);
  removeFunction(traceFuncPtr);
  return data;
}

function unifyAttachmentsOrder(attachments, bufferResults) {
  if (bufferResults && (bufferResults.length > 0) && (bufferResults[0].cl === 0))
    return attachments; // LTR all ok
  // The result is RTL, so the traced glyph indices need swapping to match the visual order
  const glyphCount = bufferResults.length;
  attachments.cursives.reverseIndices(glyphCount);
  attachments.marks.reverseIndices(glyphCount);
  return attachments;
}


let svgColors = {
  glyphBase:    '#000',
  glyphMark:    '#404',
  minBase:      '#4d4',
  minMarkBase:  '#f8c', //'#7e7',
  maxBase:      '#8af', //'#08e',
  maxExtra:     '#acf',
  maxExtraMark: 'yellow',
  collision:    '#f44',

  maxMark:      '#000', //'#e0f',
  minMark:      '#02c',
};

var hbTest = new HarfBuzzForceFieldClass();
window.hbTest = hbTest;

function glyphToMyPath(font, glyphId) {
  var ptr = font.ptr;
  var exports = harfBuzzModule.wasmExports;
  var addFunction = harfBuzzModule.addFunction;
}

var perf = []
function perfStart() {
  perf = [];
}

function perfAdd(id) {
  perf.push({txt:id, now:performance.now()});
}

function perfText() {
  const size = perf.length;
  var i = 0;
  var pnow = perf[0].now;
  var txt = '';
  while (i < size) {
    txt += (perf[i].now - pnow).toFixed(3) + ' ' + perf[i].txt + '\r\n';
    pnow = perf[i].now;
    i++;
  }
  return txt;
}

function updateValues() {
  hbTest.freeGlyphValues();
  hbTest.freeGlyphCache();
  if (showJSON.checked) {
    updateJSON();
  } else {
    hbTest.setBase(baseNear.value, baseFar.value);
    hbTest.setMark(markNear.value, markNearBase.value, markFar.value);
    baseNearValue.innerText     = baseNear.value;
    baseFarValue.innerText      = baseFar.value;
    markNearValue.innerText     = markNear.value;
    markNearBaseValue.innerText = markNearBase.value;
    markFarValue.innerText      = markFar.value;
  }
  //test(inputText.value);
  var res = processWord(inputText.value, true);
  wordRating.innerText = res.rating;
}

function getOldOrNew(theOld, theNew) {
  if (isExists(theOld))
    return theOld;
  else
    return theNew;
}

function updateJSON() {
  var data;
  jsonError.innerText = '';
  try {
    data = JSON5.parse(jsonText.value);
  } catch (e) {
    jsonError.innerText = e;
    return;
  }
  var fontCompare = null;
  hbTest.freeGlyphValues();
  hbTest.freeGlyphCache();
  hbTest.clearGroups();
  hbTest.clearDefaults();
  try {
    for (let key in data) {
      if (key === 'base') {
        const n = getOldOrNew(data.base.min, data.base.n);
        const f = getOldOrNew(data.base.max, data.base.f);
        hbTest.setBase(n, f);
      }
      else
      if (key === 'mark') {
        const n  = getOldOrNew(data.mark.min, data.mark.n);
        const nb = getOldOrNew(data.mark.min, data.mark.nb);
        const f  = getOldOrNew(data.mark.max, data.mark.f);
        hbTest.setMark(n, nb, f);
      }
      else
      if (key === 'font')
        fontCompare = data[key];
      else
      if (key === 'harfbuzz') {
        hbTest.setScriptLanguage(data[key].script, data[key].language);
      }
      else
      if (key === 'groups') {
        // Do these before 'bar' and 'overlaps' that will use the groups
        hbTest.setGroups(data[key]);
      }
      else
      if (key === 'bar') {
        // Indic bar style
        // `'bar': [
        //   {
        //     'area' : [ [y1,y2] ],
        //     'gids' : [ gid,gid,gid,],
        //   },
        //  ]`
        hbTest.setBar(data[key]);
      }
      else
      if (key === 'overlaps') {
        // GIDs that are allowed to overlap
        // Distinct from the `exclusions` for bar style overlaps
        // `'overlaps': [
        //     [gid,gid,],
        //     [gid,gid,],
        //     
        //   ]`
        hbTest.setOverlaps(data[key]);
      }
      else
      if (key === 'defaults') {
        hbTest.defaults.clusterOverlap = data[key].cl;
      }
      else
      if (key === 'far') {
        const values = data[key].values;
        if (values) hbTest.setFarValues(values);
        hbTest.farValueOk = data[key].ok;
        divFarExtraMark.hidden =  (!data[key].markPath);
        if (divFarExtraMark.hidden) cbFarExtraMark.checked = false;
        checkMarkPath = data[key].markPath;
      }
      else {
        if (typeof key === 'string') {
          const n  = getOldOrNew(data[key].min, data[key].n);
          const nb = getOldOrNew(data[key].min_base, data[key].nb);
          const f  = getOldOrNew(data[key].max, data[key].f);
          var cl = data[key].cl;

          processRangeInteger(key, hbTest.groups, function(gid,name) {
            hbTest.setGlyphValues(gid, f, n, nb, cl);
          });
        }
      }
    }
  } catch (e) {
    console.log(e);//~~~~
    jsonError.innerText = e;
  }
  if (fontCompare) {
    const name = fontCompare.name;
    const version = fontCompare.version;
    if (name && name !== hbTest.fontName.fullName) {
      jsonError.innerText = `Font name does not match "${name}"! `;
    } else
    if (version && version !== hbTest.fontName.version) {
      jsonError.innerText = `Font version does not match "${version}"!`;
    } else
    if (fontCompare.glyphNames) {
      if (!hbTest.haveGlyphNames) {
        jsonError.innerText = `Font does not appear to have glyph names!`;
      }
    }
  }

  if (!isExists(data.base) || !isExists(data.base.n) || !isExists(data.base.f)) {
    if (!isExists(data.base) || !isExists(data.base.min) || !isExists(data.base.max)) {
      jsonError.innerText = `Missing {'base':{'n':..., 'f':...}}'!`;
    }
  }

  if (!isExists(data.mark) || !isExists(data.mark.n) || !isExists(data.mark.f) || !isExists(data.mark.nb)) {
    if (!isExists(data.mark) || !isExists(data.mark.min) || !isExists(data.mark.max) || !isExists(data.mark.min_base)) {
      jsonError.innerText = `Missing {'mark':{'n':..., 'nb':..., 'f':...}}'!`;
    }
  }
  var res = processWord(inputText.value, true);
  wordRating.innerText = res.rating;
  disableDebugButtons();
}

function disableDebugButtons() {
  // Update buttons...
  btnDebugGroups.disabled = Object.keys(hbTest?.groups).length == 0;
  btnDebugGroup.disabled  = btnDebugGroups.disabled;
  btnDebugOverlaps.disabled = !hbTest.overlaps;
  btnDebugBar.disabled = !hbTest.bar;  
}

// Used for colouration of glyphs or clusters
const glyphColors = ['#bb87e3','#bc6b0e','#57118c','#64902e','#91bbec','#d65e02','#1d5799','#984c11','#271909'];

// Use specified `id` of glyph expanded outline, and return how many islands of base + all
// Called within processWord, after result has had polygons moved and applied
function testFarValue(result, id, options) {
  let overallFar   = new CPaths64();
  let overallMarks = new CPaths64();
  result.forEach(function(x) {
    const gs = x.gs;
    if (hbTest.isMarkClass(x.g)) {
      //ismark = true;
      overallMarks.unionWith(gs.path(id));
    } else {
      if (!hbTest.bar?.far && hbTest.glyphInBars(x.g))
        overallFar.unionWith(gs.path('farBar')); // TODO: handle different?
      else
        overallFar.unionWith(gs.path(id));
    }
  });
  let islandsBase = overallFar.countIslands();
  let islandsBaseMarks = islandsBase;
  if ((islandsBase > 1) && (options?.checkMarkPath)) {
    // Take the overall base path and union with each mark glyph in turn
    // Goal: looking for a mark that joins islands
    const pathName = options?.checkMarkPath;
    let ofar = overallFar.duplicatePath();
    for (let idx=0; idx<result.length; idx++) {
      const x = result[idx];
      const gs = x.gs;
      if (hbTest.isMarkClass(x.g)) {
        let o = ofar.duplicatePath();
        const p = gs.path(pathName);
        const pi = p.countIslands();
        if (pi > 1) {
          // Difficult to detect overlap
        }
        o.unionWith(p);
        let oi = o.countIslands();
        if (oi < islandsBaseMarks) {
          // Now we also know which mark is in between...
          islandsBaseMarks = oi;
          x.glue = true;
          ofar.freePath();
          ofar = o;
        } else {
          o.freePath();
        }
        if (islandsBaseMarks <= 1) {
          // No need to go further
          break;
        }
      }
    }
    ofar.freePath();
  }

  // Now join the marks overall
  overallFar.unionWith(overallMarks);
  let islandsAll = overallFar.countIslands();

  overallFar.freePath();
  overallMarks.freePath();

  return {
    base: islandsBase,
    all : islandsAll,
    basemarks: islandsBaseMarks,
    fb  : (islandsBase > 1),
    fm  : (islandsAll > islandsBase),
    ok  : (islandsAll == 1),
    fbm : (islandsBaseMarks > 1),
  }
}

function processWord(word, display) {
  const showFar      = display && cbShowFar.checked;
  //~~~~//cbShowFarMarks.disabled = !showFar;
  const showFarMarks = display && cbShowFarMarks.checked;
  const showFarExtra = display && cbShowFarExtra.checked;
  const showNear     = display && cbShowNear.checked;
  const showNearBase = display && cbShowNearBase.checked;
  const showGlyphs   = display && cbShowGlyphs.checked;
  const showCollisions = display && cbShowCollisions.checked;

  var wordRating = '';
  var buffer = hb.createBuffer();
  if (display) {
    hbTest.startSVG();
    perfStart();
    perfAdd('start');
  }
  buffer.addText(word);
  buffer.guessSegmentProperties();
  if ((typeof hbTest.script === 'string') && (hbTest.script.length > 0))
    buffer.setScript(hbTest.script || 'latn');
  if ((typeof hbTest.language === 'string') && (hbTest.language.length > 0))
    buffer.setLanguage(hbTest.language);
  if (display)
    perfAdd('shaped');

  var attachments = shapeAndFindAttachments(hbTest.font, buffer);

  const font = hbTest.font;
  var result = buffer.json(font);
  attachments = unifyAttachmentsOrder(attachments, result);

  const { Paths64, Xor64, Intersect64, Union64, TranslatePaths64, FillRule, IsPositive64 } = Clipper2Z;
  var pos = {x:0, y:0};

  result.forEach(function(x) {
    const gs = hbTest.glyphToPolyline(x.g);
    const px = pos.x + x.dx;
    const py = pos.y + x.dy;
    x.gs = gs.translateToNewGlyphSet(px, py);
    pos.x += x.ax;
    pos.y += x.ay;
  });
  if (display) perfAdd('first pass');

  var overallFar = new CPaths64();
  var overallFarExtra = {}; // of new CPaths64();
  var overallMarks = new CPaths64();
  var overallNear = new CPaths64();
  var overallNearBase = new CPaths64();
  var collisions = new CPaths64();
  var collisionCounts = {};

  pos.x = 0;
  pos.y = 0;
  var colourIndex = 0;
  var n=0;  // the result index
  const solidColour = colourSolid.checked;
  const showGids = cbShowGids.checked;
  const showGidNames = cbShowGidNames.checked;

  result.forEach(function(x) {
    colourIndex++;
    var colorText = glyphColors[colourIndex%glyphColors.length];
    const px = pos.x + x.dx;
    const py = pos.y + x.dy;

    const gs = x.gs;

    var id = `n${n}_g${x.g}_c${x.cl}`;
    var ismark = false;

    if (hbTest.isMarkClass(x.g) /*fontdata.marks[x.g]*/) {
      ismark = true;
      overallMarks.unionWith(gs.path('far'));
      if (display) {
        var color = colorText;
        if (solidColour) color = svgColors.glyphMark;
        overallNear.unionWith(gs.path('near'));
        const nearBase = gs.path('nearBase');
        if (nearBase) {
          overallNearBase.unionWith(nearBase);
        }
        if (showGlyphs) {
          hbTest.drawCPaths(gs.path('glyph'), null, {
              id:id,
              gid:x.g,
              fillColor:color, fillOpacity:0.5,
              strokeColor:svgColors.glyphMark, strokeOpacity:0.8, strokeWidth:8});
        }
      }
    } else {
      if (!hbTest.bar?.far && hbTest.glyphInBars(x.g))
        overallFar.unionWith(gs.path('farBar'));
      else
        overallFar.unionWith(gs.path('far'));
      if (display) {
        var color = colorText;
        if (solidColour) color = svgColors.glyphBase;
        let p = gs.path('nearBar');
        if (p)
          overallNear.unionWith(p);
        else
          overallNear.unionWith(gs.path('near'));
        if (showGlyphs) {
          hbTest.drawCPaths(gs.path('glyph'), null, {
              id:id,
              gid:x.g,
              fillColor:color, fillOpacity:0.5,
              strokeColor:svgColors.glyphBase, strokeOpacity:0.8, strokeWidth:8});
        }
        if (showFarExtra && !hbTest.glyphInBars(x.g)) {
          // Produce combined stack of extra far fields
          const fxmax = hbTest.farValues.length;
          for (let i=0; i<fxmax; i++) {
            const pc = hbTest.farValues[i];
            const p64 = gs.path(`far${pc}`);
            if (!overallFarExtra[i]) {
              overallFarExtra[i] = new CPaths64();
            }
            overallFarExtra[i].unionWith(p64);
          }
        }
      }
    }
    // show GID
    if (display && (showGids || showGidNames)) {
      const fontSize = 100;
      const yOfs = pos.y + 660 + (n % 4) * 110;
      const xOfs = pos.x + 0;
      const name = hbTest.getGlyphName(x.g);
      var gidtype = '';
      let gidDisplay = '';
      if (ismark) gidDisplay ='\'';
      if (showGids)
        gidDisplay += `${x.g}`;
      if (showGidNames && name) {
        if (showGids) gidDisplay += ':';
        gidDisplay += name;
      }
      hbTest.svgData += `<text font-size="${fontSize}" x="${xOfs}" y="${yOfs}" fill="${colorText}">${gidDisplay}</text>`;
    }
    pos.x += x.ax;
    pos.y += x.ay;
    n++;
  });
  if (display) {
    perfAdd('geometry+draw');
    window.hbdebug = {
      attachments: attachments,
      result: result,
      perf:perf,
    };
  }

  var i1 = 0;
  var c1 = result.length;
  while (i1 < c1) {
    const x1 = result[i1];
    var i2 = i1 + 1;
    while (i2 < c1) {
      const x2 = result[i2];
      const isCursive = attachments.cursives.findPair(i1, i2);
      if (isCursive) {
        // Ignore any collision between two cursive glyphs of the same 'set'
      } else
      if (hbTest.glyphsOverlap(x1.g, x2.g)) {
        // The glyphs are allowed to overlap
      } else {
        var collision = undefined;
        const markSet = attachments.marks.findEither(i1, i2);
        // markSet[0] = mark; markSet[1] = base
        // NOTE: This juggle is because we're not sure which way round the indices are
        if (markSet &&
            (
              (i1 == markSet[1]) ||
              (i2 == markSet[1]) ||
              attachments.cursives.findPair(i1, markSet[1]) ||
              attachments.cursives.findPair(i2, markSet[1])
            )
           )
        {
          // Going to use the Mark's glyph - not it's near-field
          if (i1 == markSet[0]) {
            // Mark to Base
            if (x1.gs.path('nearBase'))
              collision = x1.gs.path('nearBase').collisionCPath(x2.gs.path('near'));
            else
              collision = x1.gs.path('glyph').collisionCPath(x2.gs.path('near'));
          } else {
            // Base to Mark
            if (x2.gs.path('nearBase'))
              collision = x1.gs.path('near').collisionCPath(x2.gs.path('nearBase'));
            else
              collision = x1.gs.path('near').collisionCPath(x2.gs.path('glyph'));
          }
        } else {
          // Need to decide if both glyphs are part of the "bar" set (Indic)
          if (hbTest.glyphsInBars(x1.g, x2.g)) {
            collision = x1.gs.path('nearBar').collisionCPath(x2.gs.path('nearBar'));
          } else
          if (markSet && (x1.cl === x2.cl) && 
                (
                  hbTest.glyphValues[x1.g]?.clusterOverlap || 
                  hbTest.glyphValues[x2.g]?.clusterOverlap
                )
             )
          {
            // Same cluster... and are allowed to overlap
          } else {
            collision = x1.gs.path('near').collisionCPath(x2.gs.path('near'));
          }
        }

        if (collision) {
          //if (display)
          collisions.unionWith(collision);
          if (hbTest.isMarkClass(x1.g) /*fontdata.marks[x1.g]*/) {
            if (hbTest.isMarkClass(x2.g) /*fontdata.marks[x2.g]*/)
              collisionCounts.colMarkToMark = (collisionCounts.colMarkToMark || 0) + 1;
            else
              collisionCounts.colMarkToBase = (collisionCounts.colMarkToBase || 0) + 1;
          } else {
            if (hbTest.isMarkClass(x2.g) /*fontdata.marks[x2.g]*/)
              collisionCounts.colMarkToBase = (collisionCounts.colMarkToBase || 0) + 1;
            else
              collisionCounts.colBaseToBase = (collisionCounts.colBaseToBase || 0) + 1;
          }
          collision.freePath();

          // Try and see if we have a collision with the glyphs too
          collision = x1.gs.path('glyph').collisionCPath(x2.gs.path('glyph'));
          if (collision) {
            collisionCounts.colGlyph = (collisionCounts.colGlyph || 0)+1;
            collision.freePath();
          }
        }
      }
      i2++;
    }
    i1++;
  }

  if (display) perfAdd('collision done');

  if (display) {
    if (showNear) hbTest.drawCPaths(overallNear, null, {strokeColor:svgColors.minBase, strokeWidth:8});
    if (showNearBase) hbTest.drawCPaths(overallNearBase, null, {strokeColor:svgColors.minMarkBase, strokeWidth:6});
  }

  var islandsBase = overallFar.countIslands();
  if (display && showFarExtra) {
    for (let [k,v] of Object.entries(overallFarExtra)) {
      hbTest.drawCPaths(v, null, {strokeColor:svgColors.maxExtra, strokeWidth:4});
    }
  }
  if (display && !showFarMarks) {
    // Show without the marks combined
    if (showFar) hbTest.drawCPaths(overallFar, null, {strokeColor:svgColors.maxBase, strokeWidth:8});    
  }
  overallFar.unionWith(overallMarks);

  if (display && showFarMarks) {
    if (showFar)
      hbTest.drawCPaths(overallFar, null, {strokeColor:svgColors.maxBase, strokeWidth:8});        
    else
      hbTest.drawCPaths(overallMarks, null, {strokeColor:svgColors.maxBase, strokeWidth:8});        
  }
  var islandsAll = overallFar.countIslands();

  if (display) {
    if (showCollisions)
      hbTest.drawCPaths(collisions, null, {
        fillColor:svgColors.collision, fillOpacity:0.8,
        strokeColor:svgColors.collision, strokeOpacity:1.0, strokeWidth:20});
    perfAdd('islands+draw');
  }

  //\\const colSize = collisions.paths64.size();
  //\\if (colSize > 0)
  var txt = '';
  {
    if (collisionCounts.colGlyph > 0) {
      wordRating += 'GG'+collisionCounts.colGlyph+',';
      txt += 'GG'+collisionCounts.colGlyph+' ';
    }
    if (collisionCounts.colBaseToBase > 0) {
      wordRating += 'cb'+collisionCounts.colBaseToBase+',';
      txt += 'BB:'+collisionCounts.colBaseToBase+' ';
    }
    if (collisionCounts.colMarkToBase > 0) {
      wordRating += 'cx'+collisionCounts.colMarkToBase+ ',';
      txt += 'MB:'+collisionCounts.colMarkToBase+' ';
    }
    if (collisionCounts.colMarkToMark > 0) {
      wordRating += 'cm'+collisionCounts.colMarkToMark+',';
      txt += 'MM:'+collisionCounts.colMarkToMark;
    }
    const { AreaPaths64 } = Clipper2Z;
    const collisionArea = Math.round(AreaPaths64(collisions.paths64));
    if (collisionArea > 0) {
      wordRating += 'ca:'+collisionArea+',';
      txt += ' Area:'+collisionArea;
    }
    if (display) {
      colNotify.innerText = txt;
    }
  }

  txt = '';
  if ((islandsBase > 1) || (islandsAll > 1)) {
    const fb = islandsBase > 1;
    const fm = islandsAll > islandsBase;
    const ok = islandsAll == 1;

    let markIsGlue = false;
    let farBasePercent = 0;
    let farBaseMarkPercent = undefined; // far base with mark path
    let farMarkPercent = 0;
    let okPercent = undefined;
    if (ok) okPercent = 0;
    const skipOk = !hbTest.farValueOk;
    const cmp = (cbFarExtraMark.checked) ? checkMarkPath : undefined;

    for (let i=0; i<hbTest.farValues.length; i++) {
      const p = hbTest.farValues[i];
      const test = testFarValue(result, `far${p}`, {checkMarkPath: cmp});
      if (test.fb && (p > farBasePercent)) farBasePercent = p;
      if (test.fm && (p > farMarkPercent)) farMarkPercent = p;
      if (test.ok && (isNaN(okPercent) || (p < okPercent))) okPercent = p;
      if (!test.fbm) {
        if (isNaN(farBaseMarkPercent) || (p < farBaseMarkPercent))
          farBaseMarkPercent = p;
      }
      if (!cmp && (test.fb || !fb) && (test.fm || !fm) && (ok || skipOk)) {
        break;    // No point continuing
      }        
    }

    result.forEach((x) => {
      const gs = x.gs;
        if (x.glue) {
          markIsGlue = true;
          if (showFarExtra) {
            // Marked as a glue by the extra far field calc
            hbTest.drawCPaths(gs.path(checkMarkPath), null, {
              fillColor: svgColors.maxExtraMark,
              fillOpacity:0.7,
            });
          }
        }
      });

    if (fb) {
      if (!skipOk) wordRating += `ok${okPercent},`;
      if (ok) {
        if (skipOk) wordRating += 'ok,';
        txt += 'Ok? ';
        collisionCounts.okMaybe = 1;
      }
      wordRating += `fb${farBasePercent},`;
      if (markIsGlue) {
        wordRating += `mg${farBaseMarkPercent},`; // Mark is gluing together
      }
      txt += 'Base ';
      collisionCounts.farBase = 1;
    }
    if (fm) {
      wordRating += `fm${farMarkPercent},`;
      txt += 'Marks';
      collisionCounts.farMark = 1;
    }
  }
  if (display)
    farNotify.innerText = txt;

  // Free up memory...
  overallFar.freePath();
  for (let [k, v] of Object.entries(overallFarExtra)) {
    v.freePath();
  }  
  overallMarks.freePath();
  overallNear.freePath();
  overallNearBase.freePath();
  collisions.freePath();
  result.forEach(function(x) {
    x.gs.destroy();
  });
  buffer.destroy();

  wordRating = wordRating.replace(/,\s*$/,'');  // remove last comma
  if (display) {
    perfAdd('done');
    hbTest.renderSVG();
  }
  return {
    rating: wordRating,
    counts: collisionCounts,
  };
}

//var wordlistFilename = '';
var wordList = [];

//------------------------------
// Drag and drop functions
//------------------------------
////------------------------------
// Drag and drop utilities
//------------------------------
function cancel(e) {e.stopPropagation();e.preventDefault();}
function patchDragDrop(ele, foo) {
  //const ele = document.getElementById(id);
  ele.addEventListener('dragover', function(e) {
    cancel(e);
    ele.style.backgroundColor = 'yellow';
    }, false);
  ele.addEventListener('dragleave', function(e) {
    cancel(e);
    ele.style.backgroundColor = null;
    }, false);
  ele.addEventListener('drop', function(e) {
    cancel(e);
    const file = e.dataTransfer.files[0];
    ele.style.backgroundColor = null;
    foo(file, ele);
  });
}
document.addEventListener('dragover', cancel, false);
document.addEventListener('dragleave', cancel, false);
document.addEventListener('drop', cancel, false);

class wordEntryClass {
  constructor(line) {
    const tempArray = line.split('\t');
    this.word = tempArray[0];
    this.note = tempArray[1] || '';
    this.checked = false;
    //??//this.checked = (tempArray[2] === 'x') || (tempArray[2] === 'X'); //??
  }
  getWord()     { return this.word; }
  getChecked()  { return this.checked; }
  setChecked(isChecked) { this.checked = isChecked; }
  setNote(txt)  { this.note = txt; }
  getNote()     { return this.note; }
  // The line for the check list file output
  getLine() {
    const note = this.note || '';
    var txt = this.word + '\t' + note;
    // Now expand the note into separate columns
    // Order: GG#,cb#,cx#,ca:#,ok,fb,fm
    let r,v;
    r = note.match(/GG(\d+)/);
    if (r) txt += `\t${r[1]}`; else txt += '\t';

    r = note.match(/cb(\d+)/);
    if (r) txt += `\t${r[1]}`; else txt += '\t';

    r = note.match(/cx(\d+)/);
    if (r) txt += `\t${r[1]}`; else txt += '\t';

    r = note.match(/ca:(\d+)/);
    if (r) txt += `\t${r[1]}`; else txt += '\t';

    r = note.match(/ok(\d*)/);
    if (this.farValueOk) {
      if (r) txt += `\t${r[1] || '0'}`; else txt += '\t';
    } else {
      if (r) txt += `\tok`; else txt += '\t';
    }

    r = note.match(/fb(\d*)/);
    if (r) txt += `\t${r[1] || '0'}`; else txt += '\t';

    r = note.match(/fm(\d*)/);
    if (r) txt += `\t${r[1] || '0'}`; else txt += '\t';

    // Finish the line
    while (txt.endsWith('\t')) {
      txt = txt.slice(0, txt.length-1);
    }
    return txt;
  }
}

function buildListFromFileContents(txt)
{
  var lines = txt.split(/\r?\n+/g);
  var tempWordList = [];  // Start empty
  var i = 0;
  while (i < lines.length) {
    const wordEntry = new wordEntryClass(lines[i]);
    if (wordEntry.getWord().length > 0) {
      tempWordList.push(wordEntry);
    }
    i++;
  }
  return tempWordList;
}

var jsonFilename = '';
var jsonLastModifiedDate = '';

function handleJsonText(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt') && !fileName.endsWith('.json')) return;

  jsonFilename = fileName;
  jsonLastModifiedDate = file.lastModifiedDate || '?';
  showJSON.checked = true;
  rangeChange();
  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    txt = '// '+file.name+'\r\n' + txt;
    jsonText.value = txt;
    updateJSON();
  }
  reader.readAsText(file);
}

function handleWordsDrop(file) {
  if (!file) return;
  const fileName = file.name.toLowerCase();
  if (!fileName.endsWith('.txt')) return;

  window.wordlistFilename = '"'+fileName+'"';
  var reader = new FileReader();
  reader.onload = function(e) {
    var txt = e.target.result;
    wordList = buildListFromFileContents(txt);
    wordListDetails.innerText = wordList.length + ' ' + window.wordlistFilename;
    btnRateWordList.hidden = false;
    wordIndex.hidden = false;
  }
  reader.readAsText(file);
}

var AbortTheLoop = false;

function AbortReset() {
  AbortTheLoop = false;
  AbortButton.hidden = false;
}

function AbortProgress() {
  AbortTheLoop = true;
}


function handleFontUpdate(file) {
  if (!file) return;
  var reader = new FileReader();
  reader.addEventListener("load", function () {
    window.fontFileName = file.name;
    loadTheFont(new Uint8Array(reader.result));
    //updateValues();
    rangeChange();
  });
  reader.readAsArrayBuffer(file);
}

patchDragDrop(WordsDragDrop, handleWordsDrop);
patchDragDrop(theFont, handleFontUpdate);
patchDragDrop(jsonTable, handleJsonText);
patchDragDrop(rangeChoice, handleJsonText);
patchDragDrop(showJSON, handleJsonText);
patchDragDrop(slidersTable, handleJsonText);

const updateInterval = 32; // milliseconds

function secondsToHHMMSS(t) {
  if (t < 3600)
    return new Date(t * 1000).toISOString().substring(14, 19);
  else
    return new Date(t * 1000).toISOString().substring(11, 16);
}

function updateStatusMessage(i, total, checked, counts) {
  const overallTime = (Date.now() - loopStarted) / 1000.0;
  var rateWords;
  if (i < 0)
    rateWords = Math.round(total / overallTime);
  else
    rateWords = Math.round(i / overallTime);
  var eta = (total - i) / rateWords;

  if (i <= 0)
    statusUpdate.innerHTML = '-';
  else
    statusUpdate.innerHTML = `<progress max="${total}" value="${i}"></progress></br><div><font color="red">${i}/${total} (${checked})</font></br>${secondsToHHMMSS(overallTime)}/${secondsToHHMMSS(eta)} (${rateWords}/s)</div>`;

  var ol = Object.entries(counts).sort();
  var txt = '<table border=0 width="60%">';
  ol.forEach(function(e) {
    txt += '<tr><td width="50%">'+e[0] + '</th><td align="right">' + e[1]+'</td><tr>';
  });
  txt += '</table>';
  statusCounts.innerHTML = txt;
}

class ElapsedTimer {
  constructor(t) {
    this.max = t;
    this.next = performance.now() + t;
  }
  elapsed() {
    const now = performance.now();
    if (now < this.next) return false;
    while (now > this.next) this.next += this.max;
    return true;
  }
}

function setDisableAllDivElements(divName, disableValue) {
  // This will disable all the children of the div
  var nodes = document.getElementById(divName).getElementsByTagName('*');
  for(var i = 0; i < nodes.length; i++){
       nodes[i].disabled = disableValue;
  }
}

function acquireFontAndLists(opener) {
  if (!window.opener) return;
  const w = window.opener;
  if (!isExists(w.api) || !isExists(w.api.transfer)) return;
  const xfer = w.api.transfer;
  updateTransfer(xfer);
}

function updateTransfer(xfer) {
  if (!xfer) return;
  if (isExists(xfer.fontBlob1)) {
    loadTheFont(xfer.fontBlob1);
  }
  if (isExists(xfer.checkList) && (xfer.checkList.length > 0)) {
    const size = xfer.checkList.length;
    var tempList = [];
    for (let i=0; i<size; i++) {
      const word = xfer.checkList[i];
      const wordEntry = new wordEntryClass(word);
      tempList.push(wordEntry);
    }
    wordList = tempList;
    wordListDetails.innerText = wordList.length + ' ' + '(sync)';
    btnRateWordList.hidden = false;
  }
  loadPickWord(0);
  if ((xfer.script !== null) || (xfer.language !== null)) {
    inputScript.value = xfer.script || '';
    inputLanguage.value = xfer.language || '';
    updateScriptLanguage();
  }
  updateValues();
}

var loopStarted;

async function rateWordList() {
  const total = wordList.length;
  var i = 0;
  var checkcount = 0;
  var et = new ElapsedTimer(updateInterval);

  var countsOverall = {};
  loopStarted = Date.now();

  setDisableAllDivElements('slidersDiv', true);
  setDisableAllDivElements('jsonDiv', true);
  btnFCWL.disabled = true;
  btnRateWordList.disabled = true;

  AbortReset();
  for (let i=0; i<total; i++) {
    var word = wordList[i].getWord();
    var res = processWord(word);
    wordList[i].setNote(res.rating);
    if (res.rating != '') {
      wordList[i].setChecked(true);
      checkcount++;
    } else {
      wordList[i].setChecked(false);
    }
    for (var key in res.counts) {
      countsOverall[key] = (countsOverall[key] || 0) + res.counts[key];
    }
    if (et.elapsed()) {
      updateStatusMessage(i, total, checkcount, countsOverall);
      await scheduler.yield();
    }
    if (AbortTheLoop) {
      break;
    }
  }
  AbortButton.hidden = true;
  updateStatusMessage(-1, total, checkcount, countsOverall);
  saveListButton.hidden = false;
  setDisableAllDivElements('slidersDiv', false);
  setDisableAllDivElements('jsonDiv', false);
  btnFCWL.disabled = false;
  btnRateWordList.disabled = false;
}

let pickWordIndex = 0;

function loadPickWord(i) {
  const size = wordList.length;
  if (size === 0) {
    inputText.value = 'abc';
    wordIndex.value = '';
    wordIndex.hidden = true;
    return;
  }
  const we = wordList[i];
  if (i < 0) i = 0;
  if (i >= size) i = size - 1;
  inputText.value = we.getWord();
  wordIndex.value = (i+1);
  wordIndex.hidden = false;
  pickWordIndex = i;
  updateValues();
}

function randomWord(isgood) {
  var tries = 1000;
  const size = wordList.length;
  if (size == 0) return;
  while (tries > 0) {
    const i = Math.floor(Math.random() * size);
    if (i < 0) i = 0;
    if (i >= size) i = size - 1;
    const we = wordList[i];
    if ((isgood && !we.getChecked()) || (!isgood && we.getChecked())) {
      loadPickWord(i);
      return;
    }
    tries--;
  }
}

function pickWord(which) {
  const size = wordList.length;
  let i = pickWordIndex;
  if (which === 0) i = 0;
  else if (which === -1) i = pickWordIndex - 1;
  else if (which === 1) i = pickWordIndex + 1;
  else if (which === 9) i = size - 1;
  loadPickWord(i);
}

function wordIndexChange(event) {
  const i = parseInt(wordIndex.value) || 0;
  loadPickWord(i-1);
}

wordIndexGo.addEventListener('click', wordIndexChange);

function DateTimeForFilename() {
  //  012345678901234567890123
  // '2024-11-07T14:55:03.791Z'
  var d = new Date().toJSON();
  return d.slice(0,4)+d.slice(5,7)+d.slice(8,10)+'_'+
         d.slice(11,13)+d.slice(14,16)+d.slice(17,19);
}

function saveResults() {
  var txt = '';
  var i = 0;

  txt += '\t########################################\r\n';
  txt += '\t#           Font: \t'+hbTest.fileDescription+'\r\n';
  txt += '\t#           JSON: \t'+jsonFilename+' ('+jsonLastModifiedDate+')\r\n';
  txt += '\t#      Base near: \t'+hbTest.baseNear+'\r\n';
  txt += '\t#       Base far: \t'+hbTest.baseFar+'\r\n';
  txt += '\t#      Mark near: \t'+hbTest.markNear+'\r\n';
  txt += '\t# Mark near base: \t'+hbTest.markNearBase+'\r\n';
  txt += '\t#       Mark far: \t'+hbTest.markFar+'\r\n';
  txt += '\t########################################\r\n';
  txt += '\t#          Stats:  \t'+statusCounts.innerText.replace(/[\r\n]+/g, '; ')+'\r\n';
  txt += '\t########################################\r\n';
  txt += '\t#Word\tNote\tGlyphGlyph(GG)\tBaseBase(cb)\tMarkBase(cx)\tArea(ca)\tOK(ok)\tFarBase(fb)\tFarMark(fm)\r\n';

  const size = wordList.length;
  while (i < size) {
    const we = wordList[i];
    if (we.getChecked()) {
      txt = txt + we.getLine()+'\n';
    }
    i++;
  }
  var bb = new Blob([txt], {type: 'text/plain;charset=utf-8'});
  var a = document.createElement('a');
  a.download = 'FontForceField.'+DateTimeForFilename()+'.txt';
  a.href = window.URL.createObjectURL(bb);
  a.target='_blank';
  a.click();
}

// Debug function
function listGids(gid) {
  if (!gid) {
    return '!Need a GID number or name!';
  }
  let txt = '';
  let count = 0;
  const hasLetters = String(gid).search(/[A-Za-z\{\}\$\.]/) >= 0;
  processRangeInteger(gid, hbTest.groups,
    function (g,name) {
      if (hasLetters)
        txt += `${g} ${name}\r\n`;
      else {
        if (txt.length > 0) txt += ', ';
        txt += `${g}`;
      }
      count++;
    });
  console.log(`"${gid}" ->\r\n${txt}`);
  return count;
}

function listOverlaps(gid) {
  if (!hbTest.overlaps) {
    return '!No overlaps defined.';
  }
  let count = 0;
  const max = hbTest.overlaps.length;
  for (let i=0; i<max; i++) {
    const set = hbTest.overlaps[i];
    if (!gid || set.includes(gid)) {
      let txt = '';
      count++;
      set.forEach( function(v) {
        if (txt.length > 0) txt += ', ';
        txt += `${v}`;
      });
      console.log(`${i}: '${set.src}' = ${txt}`);
    }
  }
  return count;
}

function listGroup(groupName) {
  const group = hbTest?.groups[groupName];
  if (!group) {
    return '!Group not found';
  }
  let count = 0;
  let txt = '';
  for (let vv of group) {
    if (txt.length > 0) txt += ', ';
    txt += `${vv}`;
    count++;
  }
  txt = `"${groupName}" => '${group.src}' => ${txt}`;
  console.log(txt);
  return count;
}

function listGroups() {
  const groups = hbTest?.groups;
  if (!groups) {
    return '!No groups defined';
  }
  let txt = '';
  let count = 0;
  for (let key in groups) {
    if (txt.length > 0) txt += ', ';
    txt += `'${key}'`;
    count++;
  }
  console.log(txt);
  return count;
}

function listBar() {
  const bar = hbTest.bar;
  if (!bar) {
    return '!No bar defined';
  }
  let txt = '';
  let count = 0;
  const max = bar.gids.length;
  for (let i=0; i<max; i++) {
    const g = bar.gids[i];
    if (txt.length > 0) txt += ', ';
    txt += `${g}`;
    count++;
  }
  console.log(`gids: ${txt}`);
  return count;
}

function setCheckPath(pathName) {
  checkMarkPath = pathName;
}

window.updateValues = updateValues;
window.updateJSON = updateJSON;
window.rateWordList = rateWordList;
window.saveResults  = saveResults;
window.AbortProgress = AbortProgress;
window.randomWord = randomWord;
window.pickWord = pickWord;
window.opentype = opentype;
window.Layout = Layout;
window.updateTransfer = updateTransfer;
window.processRangeInteger = processRangeInteger;
window.processGlyphName = processGlyphName;
window.list = {
  gids: listGids,
  overlaps: listOverlaps,
  group: listGroup,
  groups: listGroups,
  bar: listBar,
}
window.setCheckPath = setCheckPath;
window.svgColors = svgColors;

</script>

</br>
</br>2025-12-16 n
</br><a href='https://github.com/MattMatic/font-force-field'>GitHub/MattMatic/font-force-field</a>
</body>
</html>